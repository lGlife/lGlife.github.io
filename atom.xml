<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[时间旅程 | 矛盾体]]></title>
  <subtitle><![CDATA[远离闹市才是真正的自我]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-01-01T06:02:43.643Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[LG]]></name>
    <email><![CDATA[lin151308258@gmail]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Jsp加强]]></title>
    <link href="http://yoursite.com/2015/12/31/Jsp%E5%8A%A0%E5%BC%BA/"/>
    <id>http://yoursite.com/2015/12/31/Jsp加强/</id>
    <published>2015-12-31T07:42:30.000Z</published>
    <updated>2016-01-01T06:02:43.643Z</updated>
    <content type="html"><![CDATA[<h3 id="Jsp的内置对象">Jsp的内置对象</h3><h4 id="什么是内置对象？">什么是内置对象？</h4><p>在jsp开发中，会频繁使用到一些对象。<br>　　例如HttpSession,ServletContext,ServletContext,HttpServletRequet。如果我们每次要使用这些对象都去创建这些对象就显示非常麻烦。所以Sun公司设计Jsp时，在jsp页面加载完毕之后就会自动帮开发者创建好这些对象，而开发者只需要直接使用这些对象调用方法即可！，这些创建好的对象就叫<font color="red">内置对象！！！！</font><br><strong>举例：</strong></p>
<blockquote>
<p>servlet:<br><code>HttpSession session = request.getSession(true); （需要开发者做）</code><br>jsp:<br><code>tomcat服务器：HttpSession session =request.getSession(true);(不需要开发者做)</code><br><code>开发者做的： session.getId();</code></p>
</blockquote>
<h4 id="九大内置对象">九大内置对象</h4><table>
<thead>
<tr>
<th>内置对象名</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>HttpServletRequest</td>
</tr>
<tr>
<td>response</td>
<td>HttpServletResponse</td>
</tr>
<tr>
<td>config</td>
<td>ServletConfig</td>
</tr>
<tr>
<td>application</td>
<td>ServletContext</td>
</tr>
<tr>
<td>session</td>
<td>HttpSession</td>
</tr>
<tr>
<td>exception</td>
<td>Throwable</td>
</tr>
<tr>
<td>page</td>
<td>Object(this)</td>
</tr>
<tr>
<td>out</td>
<td>JspWriter</td>
</tr>
<tr>
<td>pageContext</td>
<td>PageContext</td>
</tr>
</tbody>
</table>
<h4 id="Out对象">Out对象</h4><p>out对象类型，JspWriter类，相当于带缓存的PrintWriter</p>
<blockquote>
<p>PrintWriter<br>wrier(内容)： 直接向浏览器写出内容。<br>JspWriter<br>writer(内容): 向jsp缓冲区写出内容</p>
</blockquote>
<p>当满足以下条件之一，缓冲区内容写出：</p>
<ul>
<li>缓冲区满了</li>
<li>刷新缓存区</li>
<li>关闭缓存区</li>
<li>执行完毕jsp页面</li>
</ul>
<p><img src="/images/jspcache.png" alt=""></p>
<h4 id="pageContext对象">pageContext对象</h4><p>pageContext对象的类型是PageContext，叫jsp的上下文对象</p>
<ol>
<li>可以获取其他八个内置对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 01<span class="title">_hello_jsp</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(request,response)</span></span>&#123;</span><br><span class="line">		创建内置对象</span><br><span class="line">		HttpSession session =....;</span><br><span class="line">		ServletConfig config = ....;</span><br><span class="line"></span><br><span class="line">		把<span class="number">8</span>个经常使用的内置对象封装到PageContext对象中</span><br><span class="line">		PageContext pageContext  = 封装；</span><br><span class="line">		调用method1方法</span><br><span class="line">		method1(pageContext);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(PageContext pageContext)</span></span>&#123;</span><br><span class="line">		希望使用内置对象</span><br><span class="line">		从PageContext对象中获取其他<span class="number">8</span>个内置对象</span><br><span class="line">		JspWriter out =pageContext.getOut();</span><br><span class="line">		HttpServletRequest rquest = pageContext.getRequest();</span><br><span class="line">		........</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<font color="red">使用场景： 在自定义标签的时候，PageContext对象频繁使用到！！！</font><br> 2. 本身是一个域对象<br><br>|       |     |<br>| —– | — |<br>|ServletContext|context域|–Servlet学习的|<br>|HttpServletRequest|request域|–Servlet学习的|<br>|HttpSession|session域|–Servlet学习的|<br>|PageContext|page域 | –jsp学习的(包含四个)|<br><br>问题：Servlet里面有几个域对象，Jsp里面有几个域对象？<br><br><font color="red">域对象作用： 保存数据和获取数据，用于共享数据</font>

<blockquote>
<p>保存数据:<br>1）默认情况下，保存到page域<br>    <code>pageContext.setAttribute(&quot;name&quot;);</code><br>2）可以向四个域对象保存数据<br>    <code>pageContext.setAttribute(&quot;name&quot;,域范围常量)</code></p>
<p>获取数据:<br>1）默认情况下，从page域获取<br>    <code>pageContext.getAttribute(&quot;name&quot;)</code><br>2）可以从四个域中获取数据<br>    <code>pageContext.getAttribute(&quot;name&quot;,域范围常量)</code><br>    域范围常量:<br>    <code>PageContext.PAGE_SCOPE</code><br>    <code>PageContext.REQUEST_SCOPE</code><br>    <code>PageContext..SESSION_SCOPE</code><br>    <code>PageContext.APPLICATION_SCOPE</code><br>3）自动在四个域中搜索数据<br>    <code>pageContext.findAttribute(&quot;name&quot;);</code><br>顺序： <code>page域 -&gt; request域 -&gt; session域- &gt; context域（application域）</code></p>
</blockquote>
<h4 id="Jsp中的四个域对象">Jsp中的四个域对象</h4><ol>
<li><p>域对象作用：保存数据  和 获取数据 ，用于数据共享。</p>
</li>
<li><p>域对象方法：</p>
<blockquote>
<p>setAttribute(“name”,Object) 保存数据<br>getAttribute(“name”)  获取数据<br>removeAttribute(“name”) 清除数据</p>
</blockquote>
</li>
<li><p>域对象作用范围：</p>
<blockquote>
<font color="red">page域： 只能在当前jsp页面中使用（当前页面）<br>request域： 只能在同一个请求中使用（转发）<br>session域： 只能在同一个会话（session对象）中使用（私有的）<br>context域： 只能在同一个web应用中使用。（全局的）</font>

</blockquote>
</li>
</ol>
<h4 id="Jsp的最佳实践">Jsp的最佳实践</h4><p>Servlet技术： 开发动态资源。是一个java类，最擅长写java代码<br>jsp技术： 开发动态资源。通过java代码最擅长输出html代码。</p>
<blockquote>
<font color="red">各取所长：<br>　　在web项目中涉及到逻辑：<br>　　　　1）接收参数      servlet做<br>　　　　2）处理业务逻辑，返回结果    servlet做<br>　　　　3）显示数据到浏览器      jsp做<br>　　　　4）跳转到其他页面        servlet做<br><br>servlet+jsp模式<br>　　servlet:<br>　　　　1）接收参数<br>　　　　2）处理业务逻辑<br>　　　　3）把结果保存到域对象中<br>　　　　4）跳转到jsp页面<br>　　Jsp:<br>　　　　1）从域对象取出数据<br>　　　　2）把数据显示到浏览器<br><br>servlet的数据    -&gt;   jsp页面<br>List<contact>    使用域对象 共享数据</contact></font>

</blockquote>
<h4 id="EL表达式">EL表达式</h4>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Jsp的内置对象">Jsp的内置对象</h3><h4 id="什么是内置对象？">什么是内置对象？</h4><p>在jsp开发中，会频繁使用到一些对象。<br>　　例如HttpSession,ServletContext,ServletContext,HttpSe]]>
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Jsp基础]]></title>
    <link href="http://yoursite.com/2015/12/30/Jsp%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2015/12/30/Jsp基础/</id>
    <published>2015-12-30T06:30:25.000Z</published>
    <updated>2015-12-30T10:09:24.586Z</updated>
    <content type="html"><![CDATA[<h3 id="Jsp基础">Jsp基础</h3><ul>
<li><strong>引入</strong><br>Servlet的作用： 用java语言开发动态资源的技术！！！<br>Jsp的作用：用java语言（+html语言）开发动态资源的技术！！！<br>Jsp就是servlet！！！</li>
<li><p><strong>Jsp的特点</strong></p>
<ul>
<li><p>jsp的运行必须交给tomcat服务器！！！！</p>
<blockquote>
<p>tomcat的work目录： tomcat服务器存放jsp运行时的临时文件</p>
</blockquote>
</li>
<li><p>jsp页面既可以写html代码，也可以写java代码。</p>
<blockquote>
<p>html页面不能写java代码。而jsp页面可以写java代码</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>Jsp的执行过程</strong><br>问题： 访问<a href="http://localhost:8080/day12/01.hello.jsp" target="_blank" rel="external">http://localhost:8080/day12/01.hello.jsp</a>  如何显示效果？</p>
<ul>
<li><p>访问到01.hello.jsp页面，tomcat扫描到jsp文件，在%tomcat%/work把jsp文件翻译成java源文件</p>
<blockquote>
<p>路径与自己配置的tomcat有关联，<br><code>\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\work\Catalina\localhost\</code><br>(01.hello.jsp   -&gt;   _01_hello_jsp.java) （翻译）</p>
</blockquote>
</li>
<li><p>tomcat服务器把java源文件编译成class字节码文件 （编译）</p>
<blockquote>
<p>（_01_hello_jsp.java  -&gt;  _01_hello_jsp.class）</p>
</blockquote>
</li>
<li><p>tomcat服务器构造_01_hello_jsp类对象</p>
</li>
<li>tomcat服务器调用_01_hello_jsp类里面方法，返回内容显示到浏览器。</li>
</ul>
<font color="red"> 第一次访问jsp：    走（1）（2）（3）（4）<br>第n次访问jsp：    走（4）<br>注意：jsp文件修改了或jsp的临时文件被删除了，要重新走翻译（1）和编译  （2）的过程</font>
</li>
<li><p><strong>疑问</strong><br>问题： 为什么Jsp就是servlet！！！</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jsp翻译的java文件：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">_01_hello_jsp</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">HttpJspBase</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">JspSourceDependent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">HttpJspBase类：</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">HttpJspBase</span> <span class="keyword">extends</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">http</span>.<span class="title">HttpServlet</span> <span class="keyword">implements</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">jsp</span>.<span class="title">HttpJspPage</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<font color="red">结论：Jsp就是一个servlet程序！！！<br>　　　servlet的技术可以用在jsp程序中<br>　　　jsp的技术并不是全部适用于servlet程序！</font>

<p>Servlet的生命周期：</p>
<blockquote>
<p>构造方法（第1次访问）<br>init方法（第1次访问）<br>service方法<br>destroy方法</p>
</blockquote>
<p>Jsp的生命周期</p>
<blockquote>
<p>翻译： jsp-&gt;java文件<br>编译： java文件-&gt;class文件（servlet程序）<br>构造方法（第1次访问）<br>init方法（第1次访问）：_jspInit()<br>service方法：_jspService()<br>destroy方法：_jspDestroy()</p>
</blockquote>
<h3 id="Jsp语法">Jsp语法</h3><ul>
<li><p><strong>Jsp表达式</strong><br>语法：&lt;%=变量或表达式%&gt;<br>作用： 向浏览器输出变量的值或表达式计算的结果<br>注意：        </p>
<blockquote>
<p>表达式的原理就是翻译成out.print(“变量” );通过该方法向浏览器写出内容<br>表达式后面不需要带分号结束。</p>
</blockquote>
</li>
<li><p><strong>Jsp的脚本</strong><br>语法：&lt;%java代码 %&gt;<br>作用： 执行java代码<br>注意：</p>
<blockquote>
<p>原理把脚本中java代码原封不动拷贝到_jspService方法中执行。</p>
</blockquote>
</li>
<li><p><strong>Jsp的声明</strong><br>语法：&lt;%! 变量或方法 %&gt;<br>作用： 声明jsp的变量或方法<br>注意:</p>
<blockquote>
<p>变量翻译成成员变量，方法翻译成成员方法。<br>&lt;% 变量 %&gt;为局部变量<font color="red">不能声明方法</font>，&lt;%! 变量 %&gt;为全局变量</p>
</blockquote>
</li>
<li><strong>Jsp的注释</strong><br>语法： &lt;%!–  jsp注释  –%&gt;<br>注意：<blockquote>
<p>html的注释会被翻译和执行。而jsp的注释不能被翻译和执行。</p>
</blockquote>
</li>
</ul>
<h3 id="Jsp的三大指令">Jsp的三大指令</h3><ul>
<li><p><strong>include指令</strong><br>作用： 在当前页面用于包含其他页面<br>语法： &lt;%@include file=”common/header.jsp”%&gt;<br>注意：</p>
<blockquote>
<p>原理是把被包含的页面（header.jsp）的内容翻译到包含页面(index.jsp)中,合并成翻译成一个java源文件，再编译运行！！，这种包含叫静态包含（源码包含）<br>如果使用静态包含，被包含页面中不需要出现全局的html标签了！！！（如html、head、body）</p>
</blockquote>
</li>
<li><p><strong>page指令</strong><br>作用： 告诉tomcat服务器如何翻译jsp文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span>   --告诉服务器使用什么动态语言来翻译jsp文件</span><br><span class="line">	<span class="keyword">import</span>=<span class="string">"java.util.*"</span> --告诉服务器java文件使用什么包,导入包，多个包之间用逗号分割</span><br><span class="line">    pageEncoding=<span class="string">"utf-8"</span>  --告诉服务器使用什么编码翻译jsp文件（成java文件）</span><br><span class="line">	contentType=<span class="string">"text/html; charset=utf-8"</span>  --服务器发送浏览器的数据类型和内容编码</span><br><span class="line">	</span><br><span class="line">注意：在开发工具中，以后只需要设置pageEncoding即可解决中文乱码问题</span><br><span class="line">	errorPage=<span class="string">"error.jsp"</span></span><br><span class="line">	isErrorPage=<span class="string">"false"</span></span><br><span class="line">	buffer=<span class="string">"8kb"</span></span><br><span class="line">	session=<span class="string">"true"</span></span><br><span class="line">	isELIgnored=<span class="string">"false"</span></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>配置全局的错误处理页面：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 全局错误处理页面配置 --&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">  &lt;error-code&gt;500&lt;/error-code&gt;</span><br><span class="line">  &lt;location&gt;/common/500.jsp&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">  &lt;error-code&gt;404&lt;/error-code&gt;</span><br><span class="line">  &lt;location&gt;/common/404.html&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>taglib指令</strong></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Jsp基础">Jsp基础</h3><ul>
<li><strong>引入</strong><br>Servlet的作用： 用java语言开发动态资源的技术！！！<br>Jsp的作用：用java语言（+html语言）开发动态资源的技术！！！<br>Jsp就是serv]]>
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[会话管理]]></title>
    <link href="http://yoursite.com/2015/12/29/%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2015/12/29/会话管理/</id>
    <published>2015-12-29T06:02:12.000Z</published>
    <updated>2015-12-29T09:31:00.259Z</updated>
    <content type="html"><![CDATA[<p>会话管理： 管理浏览器客户端 和 服务器端之间会话过程中产生的会话数据。</p>
<h3 id="Cookie技术">Cookie技术</h3><font color="red">Cookie特点：会话数据保存在浏览器客户端。</font>

<h4 id="Cookie技术核心"><strong>Cookie技术核心</strong></h4><p>Cookie类：用于存储会话数据</p>
<ul>
<li>构造Cookie对象<br><code>Cookie(java.lang.String name, java.lang.String value)</code></li>
<li>设置cookie<br><code>void setPath(java.lang.String uri) 设置cookie的有效访问路径</code><br><code>void setMaxAge(int expiry) ： 设置cookie的有效时间</code><br><code>void setValue(java.lang.String newValue) ：设置cookie的值</code></li>
<li>发送cookie到浏览器端保存<br><code>void response.addCookie(Cookie cookie)  : 发送cookie</code></li>
<li>服务器接收cookie<br><code>Cookie[] request.getCookies()  : 接收cookie</code></li>
</ul>
<h4 id="Cookie原理"><strong>Cookie原理</strong></h4><ul>
<li>服务器创建cookie对象，把会话数据存储到cookie对象中。<br><code>new Cookie(&quot;name&quot;,&quot;value&quot;);</code></li>
<li>服务器发送cookie信息到浏览器<br><code>response.addCookie(cookie);</code><br><code>举例： set-cookie: name=eric  (隐藏发送了一个set-cookie名称的响应头)</code></li>
<li>浏览器得到服务器发送的cookie，然后保存在浏览器端。</li>
<li>浏览器在下次访问服务器时，会带着cookie信息<br><code>举例： cookie: name=eric  (隐藏带着一个叫cookie名称的请求头)</code></li>
<li>服务器接收到浏览器带来的cookie信息<br><code>request.getCookies();</code></li>
</ul>
<h4 id="Cookie的细节"><strong>Cookie的细节</strong></h4><ul>
<li><code>void setPath(java.lang.String uri)</code>   ：设置cookie的有效访问路径。有效路径指的是cookie的有效路径保存在哪里，那么浏览器在有效路径下访问服务器时就会带着cookie信息，否则不带cookie信息。</li>
<li><code>void setMaxAge(int expiry)</code> ： 设置cookie的有效时间。<blockquote>
<p>正整数：表示cookie数据保存浏览器的缓存目录（硬盘中），数值表示保存的时间。<br>负整数：表示cookie数据保存浏览器的内存中。浏览器关闭cookie就丢失了！！<br>零：表示删除同名的cookie数据 </p>
</blockquote>
</li>
<li>Cookie数据类型只能保存非中文字符串类型的。可以保存多个cookie，但是浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。</li>
</ul>
<h3 id="Session技术">Session技术</h3><h4 id="引入"><strong>引入</strong></h4><p>Cookie的局限：</p>
<blockquote>
<p>Cookie只能存字符串类型。不能保存对象<br>只能存非中文。<br>1个Cookie的容量不超过4KB。</p>
</blockquote>
<p>如果要保存非字符串，超过4kb内容，只能使用session技术！！！</p>
<font color="red">Session特点：会话数据保存在服务器端。（内存中）</font>

<h4 id="Session技术核心"><strong>Session技术核心</strong></h4><p>HttpSession类：用于保存会话数据</p>
<ol>
<li>创建或得到session对象<br><code>HttpSession getSession()</code><br><code>HttpSession getSession(boolean create)</code></li>
<li>设置session对象<br><code>void setMaxInactiveInterval(int interval)  ： 设置session的有效时间</code><br><code>void invalidate()     ： 销毁session对象</code><br><code>java.lang.String getId()  ： 得到session编号</code></li>
<li>保存会话数据到session对象<br><code>void setAttribute(java.lang.String name, java.lang.Object value)  ： 保存数据</code><br><code>java.lang.Object getAttribute(java.lang.String name)  ： 获取数据</code><br><code>void removeAttribute(java.lang.String name) ： 清除数据</code></li>
</ol>
<h4 id="Session原理"><strong>Session原理</strong></h4><p>问题： 服务器能够识别不同的浏览者！！<br>前提： 在哪个session域对象保存数据，就必须从哪个域对象取出！！！！</p>
<ul>
<li><p>浏览器1：(给s1分配一个唯一的标记：s001,把s001发送给浏览器)</p>
<ul>
<li>创建session对象，保存会话数据<br><code>HttpSession session = request.getSession();   --保存会话数据s1</code></li>
</ul>
</li>
<li><p>浏览器1 的新窗口（带着s001的标记到服务器查询，s001-&gt;s1,返回s1） </p>
<ul>
<li>得到session对象的会话数据<br><code>HttpSession session = request.getSession();   --可以取出  s1</code></li>
</ul>
</li>
<li><p>新的浏览器1：(没有带s001,不能返回s1)</p>
<ul>
<li>得到session对象的会话数据<br><code>HttpSession session = request.getSession();   --不可以取出  s2</code></li>
</ul>
</li>
<li><p>浏览器2：(没有带s001,不能返回s1)</p>
<ul>
<li>得到session对象的会话数据<br><code>HttpSession session = request.getSession();  --不可以取出  s3</code></li>
</ul>
</li>
</ul>
<font color="red">代码解读：<code>HttpSession session = request.getSession();</code> </font>

<ul>
<li>第一次访问创建session对象，给session对象分配一个唯一的ID，叫JSESSIONID<br><code>new HttpSession();</code></li>
<li>把JSESSIONID作为Cookie的值发送给浏览器保存<br><code>Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, sessionID);</code><br><code>response.addCookie(cookie);</code></li>
<li>第二次访问的时候，浏览器带着JSESSIONID的cookie访问服务器</li>
<li>服务器得到JSESSIONID，在服务器的内存中搜索是否存放对应编号的session对象。<blockquote>
<p><code>if(找到){
return map.get(sessionID);
}
Map&lt;String,HttpSession&gt;
&lt;&quot;s001&quot;, s1&gt;
&lt;&quot;s001,&quot;s2&gt;</code></p>
</blockquote>
</li>
<li>如果找到对应编号的session对象，直接返回该对象</li>
<li>如果找不到对应编号的session对象，创建新的session对象，继续走1的流程</li>
</ul>
<font color="red">结论：通过JSESSION的cookie值在服务器找session对象！！！！！</font>

<h4 id="Sesson细节"><strong>Sesson细节</strong></h4><ul>
<li><code>java.lang.String getId()</code>  ： 得到session编号</li>
<li>两个getSession方法：<ul>
<li><code>getSession(true) / getSession()</code>  : 创建或得到session对象。没有匹配的session编号，自动创建新的session对象。</li>
<li><code>getSession(false)</code>: 得到session对象。没有匹配的session编号，返回null</li>
</ul>
</li>
<li><code>void setMaxInactiveInterval(int interval)</code>  ： 设置session的有效时间<br><font color="red">session对象销毁时间</font>：<ul>
<li>默认情况30分服务器自动回收</li>
<li>修改session回收时间</li>
<li>全局修改session有效时间<blockquote>
<p><code>&lt;!-- 修改session全局有效时间:分钟 --&gt;
&lt;session-config&gt;
&lt;session-timeout&gt;1&lt;/session-timeout&gt;
&lt;/session-config&gt;</code></p>
</blockquote>
</li>
<li>手动销毁session对象<br><code>void invalidate()： 销毁session对象</code></li>
</ul>
</li>
<li>如何避免浏览器的JSESSIONID的cookie随着浏览器关闭而丢失的问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 手动发送一个硬盘保存的cookie给浏览器</span><br><span class="line">*/</span></span><br><span class="line">Cookie c = <span class="keyword">new</span> Cookie(<span class="string">"JSESSIONID"</span>,session.getId());</span><br><span class="line">c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">response.addCookie(c);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结">总结</h3><ul>
<li><p>Cookie技术： 会话数据保存在浏览器客户端。</p>
<blockquote>
<p>Cookie核心的API：<br>在服务器端创建Cookie对象<br><code>Cookeie cookie = new Cookie(&quot;name&quot;,&quot;value&quot;);</code><br>把cookie发送给浏览器端（通过响应头：set-cookie）<br><code>response.addCookie(cookie);</code><br>浏览器带着cookie信息访问服务器（通过请求头：cookie），服务器得到cookie信息<br><code>Cookie[] cookies = request.getCookies();</code></p>
<font color="red">局限：<br>只能保存字符串类型，不能保存中文<br>一个cookie不能超过4kb</font>
</blockquote>
</li>
<li><p>Session技术：会话数据保存在服务器端。（内存）</p>
<blockquote>
<p>Session核心的API：<br>创建或得到session对象<br><code>HttpSession session = request.getSession(); //创建或得到session对象</code><br><code>request.getSession(false); //得到session对象</code><br>会话数据保存session对象中，和得到会话数据<br><code>session.setAttribute(&quot;name&quot;,Object);  保存数据</code><br><code>session.getAttribute(&quot;name&quot;)   得到数据</code><br><font color="red">注意</font>：<br><code>session.setIntactiveInterval(时间);   设置session过期时间</code><br><code>session.invalidate()  手动销毁session对象</code></p>
</blockquote>
</li>
</ul>
<p>此文章知识点来源传智博客发布的学习教程里面。以后会定期的更新，记录自己的学习历程，总结所学的知识点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>会话管理： 管理浏览器客户端 和 服务器端之间会话过程中产生的会话数据。</p>
<h3 id="Cookie技术">Cookie技术</h3><font color="red">Cookie特点：会话数据保存在浏览器客户端。</font>

<h4 id="Cookie技]]>
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[servlet编程]]></title>
    <link href="http://yoursite.com/2015/12/28/servlet%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2015/12/28/servlet编程/</id>
    <published>2015-12-28T01:24:51.000Z</published>
    <updated>2015-12-29T08:02:54.754Z</updated>
    <content type="html"><![CDATA[<h3 id="如何开发一个Servlet">如何开发一个Servlet</h3><p>步骤</p>
<ol>
<li>编写java类，继承HttpServlet类</li>
<li>重新doGet和doPost方法</li>
<li>在wed.xml文件中进行配置</li>
<li>Servlet程序交给tomcat服务器运行<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置一个servlet --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- servlet的配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>FirstServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- servlet的类全名： 包名+简单类名 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>gz.itcast.a_servlet.FirstServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- servlet的映射配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt;</span></span><br><span class="line">  	    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>FirstServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">  	    <span class="comment">&lt;!-- servlet的映射路径（访问servlet的名称） --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/first<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>前提</strong>：<br>tomcat服务器启动时，首先加载webapps中的每个web应用的web.xml配置文件<br>http:// :http协议<br>localhost：在本地host文件中查找对应的IP地址（127.0.0.1）<br>8080：找到tomcat服务器(对应的端口)<br>/day10：在tomcat的webapps目录下找day10的目录<br>/first：资源名称</p>
<blockquote>
<p>在day10的web.xml中查找是否有匹配的url-pattern的内容（/first）<br> 如果匹配，则取出对应的servlet-name的名称，查看是否有对应的servlet配置<br> 如果匹配，则取出对应的servlet配置信息中的class内容：<br> <font color="red">通过反射:构造FirstServlet的对象，然后调用FirstServlet里面的方法</font></p>
</blockquote>
<h3 id="Servlet的映射文件">Servlet的映射文件</h3><p>精确匹配：</p>
<table>
<thead>
<tr>
<th>url-pattern配置</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>/first</td>
<td>http：//localhost:8080/day10/first</td>
</tr>
<tr>
<td>/itcast/demo1</td>
<td>http：//localhost:8080/day10/itcast/demo1</td>
</tr>
</tbody>
</table>
<p>模糊匹配：</p>
<table>
<thead>
<tr>
<th>url-pattern配置</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>/*</td>
<td>http：//localhost:8080/day10/任意路径</td>
</tr>
<tr>
<td>/itcast/*</td>
<td>http：//localhost:8080/day10/itcast/任意路径</td>
</tr>
<tr>
<td>*.后缀名（.do/.action）</td>
<td>http：//localhost:8080/day10/任意路径.do</td>
</tr>
</tbody>
</table>
<font color="red"><strong>注意</strong></font>

<ul>
<li>url-pattern要么以 / 开头，要么以*开头。  例如， itcast是非法路径。</li>
<li>不能同时使用两种模糊匹配，例如 /itcast/*.do是非法路径</li>
<li>当有输入的URL有多个servlet同时被匹配的情况下：<ul>
<li>精确匹配优先。（长的最像优先被匹配） </li>
<li>以后缀名结尾的模糊url-pattern优先级最低！！！</li>
</ul>
</li>
</ul>
<h3 id="Servlet缺省路径">Servlet缺省路径</h3><p>　　servlet的缺省路径(<code>&lt;url-pattern&gt;/&lt;/url-pattern&gt;</code>）是在tomcat服务器内置的一个路径。该路径对应的是一个DefaultServlet（缺省Servlet）。这个缺省的Servlet的作用是用于解析web应用的静态资源文件。<br>问题： URL输入<a href="http://localhost:8080/day10/index.html" target="_blank" rel="external">http://localhost:8080/day10/index.html</a> 如何读取文件？？？？</p>
<ul>
<li>到当前day10应用下的web.xml文件查找是否有匹配的url-pattern。</li>
<li>如果没有匹配的url-pattern，则交给tomcat的内置的DefaultServlet处理</li>
<li>DefaultServlet程序到day10应用的根目录下查找是存在一个名称为index.html的静态文件。</li>
<li>如果找到该文件，则读取该文件内容，返回给浏览器。</li>
<li>如果找不到该文件，则返回404错误页面。<font color="red">结论： 先找动态资源，再找静态资源。</font>

</li>
</ul>
<h3 id="Servlet的生命周期">Servlet的生命周期</h3><h4 id="引入"><strong>引入</strong></h4><p>Servlet的生命周期： servlet类对象什么时候创建，什么时候调用什么方法，什么时候销毁。<br>以前的对象： new Student（）； stu.study();   stu=null;<br>Servlet程序的生命周期由tomcat服务器控制的！！！！</p>
<h4 id="Servlet重要的四个生命周期方法"><strong>Servlet重要的四个生命周期方法</strong></h4><p>构造方法： 创建servlet对象的时候调用。默认情况下，第一次访问servlet的时候创建servlet对象。只调用1次。证明servlet对象在tomcat是单实例的。<br>init方法： 创建完servlet对象的时候调用。只调用1次。<br>service方法： 每次发出请求时调用。调用n次。<br>destroy方法： 销毁servlet对象的时候调用。停止服务器或者重新部署web应用时销毁servlet对象。只调用1次。</p>
<h4 id="伪代码演示Servlet的生命周期"><strong>伪代码演示Servlet的生命周期</strong></h4><p>Tomcat内部代码运行:</p>
<ul>
<li>通过映射找到到servlet-class的内容，字符串： <code>gz.itcast.a_servlet.FirstServlet</code></li>
<li>通过反射构造FirstServlet对象</li>
<li>得到字节码对象<br><code>Class clazz = class.forName(&quot;gz.itcast.a_servlet.FirstServlet&quot;);</code></li>
<li>调用无参数的构造方法来构造对象<br><code>Object obj = clazz.newInstance();</code>  <font color="red">—1.servlet的构造方法被调用</font></li>
<li>创建ServletConfig对象，通过反射调用init方法</li>
<li>得到方法对象<br><code>Method m = clazz.getDeclareMethod(&quot;init&quot;,ServletConfig.class);</code></li>
<li>调用方法<br><code>m.invoke(obj,config);</code><font color="red">–2.servlet的init方法被调用</font></li>
<li>创建request，response对象，通过反射调用service方法</li>
<li>得到方法对象<br><code>Methodm m =clazz.getDeclareMethod(&quot;service&quot;,HttpServletRequest.class,HttpServletResponse.class);</code></li>
<li>调用方法<br><code>m.invoke(obj,request,response);</code>  <font color="red">–3.servlet的service方法被调用</font></li>
<li>当tomcat服务器停止或web应用重新部署，通过反射调用destroy方法</li>
<li>得到方法对象<br><code>Method m = clazz.getDeclareMethod(&quot;destroy&quot;,null);</code></li>
<li>调用方法<br><code>m.invoke(obj,null);</code>            <font color="red">–4.servlet的destroy方法被调用</font></li>
</ul>
<h3 id="用时序图来演示servlet的生命周期">用时序图来演示servlet的生命周期</h3><p><img src="/images/servlet.png" alt=""></p>
<h3 id="Servlet的自动加载">Servlet的自动加载</h3><p>默认情况下，第一次访问servlet的时候创建servlet对象。如果servlet的构造方法或init方法中执行了比较多的逻辑代码，那么导致用户第一次访问sevrlet的时候比较慢。<br>改变servlet创建对象的时机： 提前到加载web应用的时候！！！<br>在servlet的配置信息中，加上一个<load-on-startup>即可！！<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt; </span><br><span class="line">        &lt;servlet-<span class="property">name</span>&gt;LifeDemo&lt;/servlet-<span class="property">name</span>&gt;</span><br><span class="line">        &lt;servlet-<span class="type">class</span>&gt;gz.itcast.c_life.LifeDemo&lt;/servlet-<span class="type">class</span>&gt;</span><br><span class="line">        &lt;load-<span class="function_start"><span class="keyword">on</span></span>-startup&gt;<span class="number">1</span>&lt;/load-<span class="function_start"><span class="keyword">on</span></span>-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure></load-on-startup></p>
<h3 id="Servlet的多线程并发问题">Servlet的多线程并发问题</h3><font color="red">注意： servlet对象在tomcat服务器是单实例多线程的。</font><br>　　因为servlet是多线程的，所以当多个servlet的线程同时访问了servlet的共享数据，如成员变量，可能会引发线程安全问题。<br><br>解决办法：<br>　　把使用到共享数据的代码块进行同步（使用<code>synchronized</code>关键字进行同步）<br>　　建议在servlet类中尽量不要使用成员变量。如果确实要使用成员，必须同步。而且尽量缩小同步代码块的范围。（哪里使用到了成员变量，就同步哪里！！），以避免因为同步而导致并发效率降低。<br><font color="red">Servlet学习</font>

<blockquote>
<p>HttpServletRequest  请求对象：获取请求信息<br>HttpServletResponse 响应对象： 设置响应对象<br>ServletConfig对象    servlet配置对象<br>ServletContext对象 servlet的上下文对象</p>
</blockquote>
<h3 id="ServletConfig对象">ServletConfig对象</h3><h4 id="作用"><strong>作用</strong></h4><p>　　ServletConfig对象:＜主要是用于加载servlet的初始化参数。在一个web应用可以存在多个ServletConfig对象（一个Servlet对应一个ServletConfig对象）</p>
<h4 id="对象创建和得到"><strong>对象创建和得到</strong></h4><p>创建时机： 在创建完servlet对象之后，在调用init方法之前创建。<br>得到对象： 直接从有参数的init方法中得到！！！</p>
<h4 id="servlet的初始化参数配置"><strong>servlet的初始化参数配置</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>ConfigDemo<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>gz.itcast.f_config.ConfigDemo<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 初始参数： 这些参数会在加载web应用的时候，封装到ServletConfig对象中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="title">param-name</span>&gt;</span>path<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="title">param-value</span>&gt;</span>e:/b.txt<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<font color="red">注意： servlet的参数只能由当前的这个sevlet获取！！！！<br></font>ServletConfig的API：<font color="red"></font>

<ul>
<li>java.lang.String getInitParameter(java.lang.String name)  根据参数名获取参数值</li>
<li>java.util.Enumeration getInitParameterNames()    获取所有参数</li>
<li>ServletContext getServletContext()     得到servlet上下文对象</li>
<li>java.lang.String getServletName()       得到servlet的名称</li>
</ul>
<h3 id="ServletContext对象">ServletContext对象</h3><h4 id="引入-1"><strong>引入</strong></h4><p>　　ServletContext对象,叫做Servlet的上下文对象。表示一个当前的web应用环境。一个web应用中只有一个ServletContext对象。</p>
<h4 id="对象创建和得到-1"><strong>对象创建和得到</strong></h4><p>创建时机：加载web应用时创建ServletContext对象。<br>得到对象：从ServletConfig对象的getServletContext方法得到<br>Sun公司设计:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">创建ServletContext对象  ServletContext context = <span class="keyword">new</span> ServletContext()</span><br><span class="line">创建ServletConfig对象   ServetConfig config = <span class="keyword">new</span> ServletConfig();</span><br><span class="line">                        config.setServletContxt(context);</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ServletConfig</span></span>&#123;</span><br><span class="line">	ServletContext context;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContxt</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> contxt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">( ServletConfig config )</span></span>&#123;</span><br><span class="line">	得到ServletConfig对象</span><br><span class="line">	从ServletConfig对象中得到ServletContext对象</span><br><span class="line">	SerlvetContext context = config.getServletContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="ServletContext对象的核心API(作用)"><strong>ServletContext对象的核心API(作用)</strong></h4><blockquote>
<p>java.lang.String getContextPath()   –得到当前web应用的路径(<font color="red">用在请求重定向的资源名称中</font>)</p>
<p>java.lang.String getInitParameter(java.lang.String name)  –得到web应用的初始化参数<br>java.util.Enumeration getInitParameterNames()  </p>
<p>void setAttribute(java.lang.String name, java.lang.Object object) –域对象有关的方法<br>java.lang.Object getAttribute(java.lang.String name)<br>void removeAttribute(java.lang.String name)  </p>
<p>RequestDispatcher getRequestDispatcher(java.lang.String path)   –转发（类似于重定向）</p>
<p>java.lang.String getRealPath(java.lang.String path)     –得到web应用的资源文件<br>java.io.InputStream getResourceAsStream(java.lang.String path) </p>
</blockquote>
<h4 id="域对象有关的方法"><strong>域对象有关的方法</strong></h4><p>域对象：作用是用于保存数据，获取数据。可以在不同的动态资源之间共享数据。<br>案例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">案例<span class="number">1</span>：</span><br><span class="line">response.sendRedirect(<span class="string">"/Servlet2?name=eric"</span>)</span><br><span class="line">String request.getParameter(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">案例<span class="number">2</span>:</span><br><span class="line"><span class="comment">//保存数据</span></span><br><span class="line"><span class="comment">//1.得到域对象</span></span><br><span class="line">ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line"><span class="comment">//2.把数据保存到域对象中</span></span><br><span class="line">context.setAttribute(<span class="string">"name"</span>, <span class="string">"eric"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数据</span></span><br><span class="line"><span class="comment">//1.得到域对象</span></span><br><span class="line">ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line"><span class="comment">//2.从域对象中取出数据</span></span><br><span class="line">String name = (String)context.getAttribute(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure></p>
<p>方案1： 可以通过传递参数的形式，共享数据。局限：只能传递字符串类型。<br>方案2： 可以使用域对象共享数据，<font color="red">好处：可以共享任何类型的数据！！！！！</font></p>
<p>ServletContext就是一个域对象！！！！</p>
<ul>
<li>保存数据：void setAttribute(java.lang.String name, java.lang.Object object)                    </li>
<li>获取数据： java.lang.Object getAttribute(java.lang.String name)  </li>
<li>删除数据： void removeAttribute(java.lang.String name)  </li>
</ul>
<font color="red">ServletContext域对象：作用范围在整个web应用中有效！！！<br>所有域对象</font>

<blockquote>
<p>HttpServletRequet 域对象<br>ServletContext域对象<br>HttpSession 域对象<br>PageContext域对象    </p>
</blockquote>
<h4 id="转发法"><strong>转发法</strong></h4><p><code>RequestDispatcher getRequestDispatcher(java.lang.String path)</code><br>转发<br><code>request.setAttribute(&quot;name&quot;,&quot;rose&quot;);</code><br><code>this.getServletContext().getRequestDispatcher(&quot;/GetDateServlet&quot;).forward(request, response);</code></p>
<ul>
<li>地址栏不会改变</li>
<li>转发只能转发到当前web应用内的资源</li>
<li>可以在转发过程中，可以把数据保存到request域对象中</li>
</ul>
<p>重定向<br><code>response.sendRedirect(&quot;/day10/GetDataServlet&quot;);</code></p>
<ul>
<li>地址栏会改变，变成重定向到地址。</li>
<li>重定向可以跳转到当前web应用，或其他web应用，甚至是外部域名网站。</li>
<li>不能再重定向的过程，把数据保存到request中。</li>
</ul>
<font color="red">结论： 如果要使用request域对象进行数据共享，只能用转发技术！！！</font>

<h3 id="总结">总结</h3><h4 id="Servlet编程">Servlet编程</h4><ul>
<li>Servlet生命周期（重点）<ul>
<li>构造方法： 创建servlet对象。默认情况下，第一次访问servlet对象时。只调用1次。</li>
<li>init方法（有参）： 创建完servlet对象后调用。只调用1次。注意： 会调用无参的init方法。</li>
<li>service方法： servlet提供服务的方法。每次发出请求调用。注意： request对象 ，response对象</li>
<li>destroy方法：tomcat服务器停止或web应用重新部署，servlet对象销毁，destroy方法被调用。</li>
</ul>
</li>
<li>ServletConfig对象<ul>
<li>获取servlet的初始化参数：<blockquote>
<p>getInitParameter(“name”);<br>getInitParameterNames();</p>
</blockquote>
</li>
</ul>
</li>
<li><p>ServletContext对象</p>
<ul>
<li><p>得到web应用路径：</p>
<blockquote>
<p>context.getContextPath();<br>request.getContextPath();  等价于上面的代码</p>
</blockquote>
</li>
<li><p>得到web应用参数：</p>
<blockquote>
<p>context.getInitParameter(“name”);<br>context.getInitParameterNames();</p>
</blockquote>
</li>
<li><p>域对象:</p>
<blockquote>
<p>context.setAttribute(“name”,Object): 保存数据<br>context.getAttribute(“name”)   得到数据<br>context.removeAttribue(“name”)  清除数据</p>
</blockquote>
</li>
<li><p>转发</p>
<blockquote>
<p>context.getRequestDispatcher(“路径”).forward(request,response);<br>request.getRequestDispacher(“路径”).forward(request,response);  等价于上面的代码</p>
</blockquote>
</li>
<li>得到web应用中的资源文件<blockquote>
<p>context.getRealPath(“路径”)<br>context.getResourceAsStream(“路径”);</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>此文章知识点来源传智博客发布的学习教程里面。以后会定期的更新，记录自己的学习历程，总结所学的知识点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="如何开发一个Servlet">如何开发一个Servlet</h3><p>步骤</p>
<ol>
<li>编写java类，继承HttpServlet类</li>
<li>重新doGet和doPost方法</li>
<li>在wed.xml文件中进行配置</li>
<]]>
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Http协议]]></title>
    <link href="http://yoursite.com/2015/12/24/Http%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2015/12/24/Http协议/</id>
    <published>2015-12-24T03:21:02.000Z</published>
    <updated>2015-12-25T09:40:52.809Z</updated>
    <content type="html"><![CDATA[<h3 id="什么是http协议">什么是http协议</h3><p>http协议：对浏览器客户端和服务端之间数据传输的格式规范<font color="red">数据传输的格式规范</font></p>
<h3 id="查看http协议的工具">查看http协议的工具</h3><ol>
<li>使用火狐的firebug插件（右键-&gt;firebug-&gt;网络）</li>
<li>使用谷歌的“审查元素”</li>
<li>使用系统自带的telnet工具（远程访问工具）</li>
</ol>
<ul>
<li><code>telnet localhost 8080</code>    访问tomcat服务器</li>
<li><kbd>ctrl</kbd>   回车    可以看到回显</li>
<li>输入请求内容</li>
<li>回车，即可查看到服务器响应信息。</li>
</ul>
<h3 id="http协议版本">http协议版本</h3><ul>
<li>http1.0：当前浏览器客户端与服务器端建立连接之后，只能发送一次请求，一次请求之后连接关闭。</li>
<li>http1.1：当前浏览器客户端与服务器端建立连接之后，可以在一次连接中发送多次请求。（基本都使用1.1）</li>
</ul>
<h2 id="http请求">http请求</h2><blockquote>
<p>GET /day09/hello HTTP/1.1  -请求行<br>Host: localhost:8080                    –请求头（多个key-value对象）<br>User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>Accept-Language: zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3<br>Accept-Encoding: gzip, deflate<br>Connection: keep-alive            –一个空行<br>name=eric&amp;password=123456             –（可选）实体内容</p>
</blockquote>
<h3 id="请求资源与方式">请求资源与方式</h3><p>URL:统一资源定位符，只能定位互联网资源，是URI的子集。<br>URI:统一资源标记符，用于标记任何资源，可以是本地文件系统，局域网资源，互联网资源。<br>常见的请求方式：<font color="red">GET、POST</font>、HEAD、TRACE、PUT、CONNECT、DELETE</p>
<ul>
<li>GET方式提交<ul>
<li>地址栏（URI）会跟上参数数据。以？开头，多个参数之间以&amp;分割。</li>
<li>GET提交参数数据有限制，不超过1KB。</li>
<li>GET方式不适合提交敏感密码。</li>
<li>注意： 浏览器直接访问的请求，默认提交方式是GET方式</li>
</ul>
</li>
<li>POST方式提交<ul>
<li>参数不会跟着URI后面。<font color="red">参数而是跟在请求的实体内容中</font>。没有？开头，多个参数之间以&amp;分割。</li>
<li>POST提交的参数数据没有限制。</li>
<li>POST方式提交敏感数据。</li>
</ul>
</li>
</ul>
<h3 id="请求头">请求头</h3><blockquote>
<p>Accept: text/html,image/*      – 浏览器接受的数据类型<br>Accept-Charset: ISO-8859-1     – 浏览器接受的编码格式<br>Accept-Encoding: gzip,compress  –浏览器接受的数据压缩格式<br>Accept-Language: en-us,zh-       –浏览器接受的语言<br>Host: www.it315.org:80          –（必须的）当前请求访问的目标地址（主机:端口）<br>If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT  –浏览器最后的缓存时间<br>Referer: <a href="http://lglife.github.io/" target="_blank" rel="external">http://lglife.github.io/</a>      – 当前请求来自于哪里<br>User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)  –浏览器类型<br>Cookie:name=eric                     – 浏览器保存的cookie信息<br>Connection: close/Keep-Alive            – 浏览器跟服务器连接状态。close: 连接关闭  keep-alive：保存连接。<br>Date: Tue, 11 Jul 2000 18:23:51 GMT      – 请求发出的时间</p>
</blockquote>
<h3 id="HttpServletRequest对象">HttpServletRequest对象</h3><p>HttpServletRequest对象作用是用于获取请求数据。</p>
<pre><code>核心的<span class="type">API</span>：
    请求行： 
        request.getMethod<span class="literal">()</span>;   请求方式
        request.getRequetURI<span class="literal">()</span>/ request.getRequetURL<span class="literal">()</span>请求资源
        request.getProtocol<span class="literal">()</span>   请求http协议版本
    请求头：
        request.getHeader(<span class="string">"名称"</span>)   根据请求头获取请求值
        request.getHeaderNames<span class="literal">()</span>    获取所有的请求头名称
    实体内容:
        request.getInputStream<span class="literal">()</span>   获取实体内容数据
    获取参数:
        request.getParameter(<span class="string">"参数名"</span>);  根据参数名获取参数值（注意，只能获取一个值的参数）
        request.getParameterValue(<span class="string">"参数名“)；根据参数名获取参数值（可以获取多个值的参数）
        request.getParameterNames();   获取所有参数名称列表
    获取GET方式参数：
        request.getQueryString();
    获取POST方式参数：
        request.getInputStream();
    修改POST方式参数编码：
        request.setCharacterEncoding("</span>utf-<span class="number">8</span><span class="string">");
    修改GET方式参数编码：
        手动解码：String name = new String(name.getBytes("</span>iso-<span class="number">8859</span>-<span class="number">1</span><span class="string">"),"</span>utf-<span class="number">8</span><span class="string">");</span>
</code></pre><h2 id="http请求-1">http请求</h2><blockquote>
<p>HTTP/1.1 200 OK                –响应行<br>Server: Apache-Coyote/1.1         –响应头（key-vaule）<br>Content-Length: 24<br>Date: Fri, 30 Jan 2015 01:54:57 GMT           –一个空行<br>this is hello servlet!!!                  –实体内容</p>
</blockquote>
<h3 id="状态码">状态码</h3><p>服务器处理请求的结果（状态）,常见的状态</p>
<ul>
<li>200：表示请求处理完成并完美返回</li>
<li>302：表示请求需要进一步细化。</li>
<li>404：表示客户访问的资源找不到。</li>
<li>500：表示服务器的资源发送错误。（服务器内部错误）</li>
</ul>
<h3 id="常见的响应头">常见的响应头</h3><blockquote>
<p>Location: <a href="http://lglife.github.io/" target="_blank" rel="external">http://lglife.github.io/</a>   -表示重定向的地址，该头和302的状态码一起使用。<br>Server:apache tomcat                 —表示服务器的类型<br>Content-Encoding: gzip                 – 表示服务器发送给浏览器的数据压缩类型<br>Content-Length: 80                    –表示服务器发送给浏览器的数据长度<br>Content-Language: zh-cn               –表示服务器支持的语言<br>Content-Type: text/html; charset=GB2312   –表示服务器发送给浏览器的数据类型及内容编码<br>Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT  –表示服务器资源的最后修改时间<br>Refresh: 1;url=<a href="http://lglife.github.io/" target="_blank" rel="external">http://lglife.github.io/</a>     –表示定时刷新<br>Content-Disposition: attachment; filename=aaa.zip –表示告诉浏览器以下载方式打开资源（下载文件时用到）<br>Transfer-Encoding: chunked<br>Set-Cookie:SS=Q0=5Lb_nQ; path=/search   –表示服务器发送给浏览器的cookie信息（会话管理用到）<br>Expires: -1                           –表示通知浏览器不进行缓存<br>Cache-Control: no-cache<br>Pragma: no-cache<br>Connection: close/Keep-Alive           –表示服务器和浏览器的连接状态。close：关闭连接 keep-alive:保存连接</p>
</blockquote>
<h3 id="HttpServletResponse对象">HttpServletResponse对象</h3><p>HttpServletResponse对象修改响应信息：</p>
<pre><code>响应行： 
    response.setStatus<span class="literal">()</span>  设置状态码
响应头： 
    response.setHeader(<span class="string">"name"</span>,<span class="string">"value"</span>)  设置响应头
实体内容：
    response.getWriter<span class="literal">()</span>.writer<span class="literal">()</span>;   发送字符实体内容
    response.getOutputStream<span class="literal">()</span>.writer<span class="literal">()</span>  发送字节实体内容
</code></pre><p>此文章知识点来源传智博客发布的学习教程里面。以后会定期的更新，记录自己的学习历程，总结所学的知识点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="什么是http协议">什么是http协议</h3><p>http协议：对浏览器客户端和服务端之间数据传输的格式规范<font color="red">数据传输的格式规范</font></p>
<h3 id="查看http协议的工具">查看http协议的工具</h3]]>
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sublime text2 插件安装及激活]]></title>
    <link href="http://yoursite.com/2015/12/23/ublime-text2-%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%8A%E6%BF%80%E6%B4%BB/"/>
    <id>http://yoursite.com/2015/12/23/ublime-text2-插件安装及激活/</id>
    <published>2015-12-23T09:19:54.000Z</published>
    <updated>2015-12-25T06:23:39.223Z</updated>
    <content type="html"><![CDATA[<h3 id="sublime_text2_破解">sublime text2 破解</h3><p>打开Sublime Text，看到标题栏上面带有（unregistered）,表示没有注册。复制下面代码，打开注册页面（help-enter license）,点击 use license即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">----- BEGIN LICENSE -----</span><br><span class="line"></span><br><span class="line">Andrew Weber</span><br><span class="line"></span><br><span class="line">Single User License</span><br><span class="line"></span><br><span class="line">EA7E-<span class="number">855605</span></span><br><span class="line"></span><br><span class="line"><span class="number">813</span>A03DD <span class="number">5E4</span>AD9E6 <span class="number">6</span>C0EEB94 BC99798F</span><br><span class="line"></span><br><span class="line"><span class="number">942194</span>A6 <span class="number">02396E98</span> E62C9979 <span class="number">4</span>BB979FE</span><br><span class="line"></span><br><span class="line"><span class="number">91424</span>C9D A45400BF F6747D88 <span class="number">2F</span>B88078</span><br><span class="line"></span><br><span class="line"><span class="number">90F</span>5CC94 <span class="number">1</span>CDC92DC <span class="number">8457107</span>A F151657B</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>D22E383 A997F016 <span class="number">42397640</span> <span class="number">33F</span>41CFC</span><br><span class="line"></span><br><span class="line">E1D0AE85 A0BBD039 <span class="number">0E9</span>C8D55 E1B89D5D</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>CDB7036 E56DE1C0 EFCC0840 <span class="number">650</span>CD3A6</span><br><span class="line"></span><br><span class="line">B98FC99C <span class="number">8F</span>AC73EE D2B95564 DF450523</span><br><span class="line"></span><br><span class="line">------ END LICENSE ------</span><br></pre></td></tr></table></figure></p>
<h3 id="sublime_text2_插件安装">sublime text2 插件安装</h3><p>打开命令输入框（view-show console）或者按ctrl+`调出窗口，复制下面代码按回车：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib2,os;pf=<span class="string">'Package Control.sublime-package'</span>;ipp=sublime.installed_packages_path();os.makedirs(ipp) <span class="keyword">if</span> <span class="keyword">not</span> os.path.<span class="keyword">exists</span>(ipp) <span class="keyword">else</span> None;<span class="keyword">open</span>(os.path.<span class="keyword">join</span>(ipp,pf),<span class="string">'wb'</span>).<span class="keyword">write</span>(urllib2.urlopen(<span class="string">'http://sublime.wbond.net/'</span>+pf.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)).<span class="keyword">read</span>())</span><br></pre></td></tr></table></figure></p>
<p>点击Preferences下拉窗口有 package control 即安装组件成功。<br>按ctrl+shift+p或者点击package control调出命令面板，输入install package 回车或者点击，然后就可以选择自己想要的插件安装。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="sublime_text2_破解">sublime text2 破解</h3><p>打开Sublime Text，看到标题栏上面带有（unregistered）,表示没有注册。复制下面代码，打开注册页面（help-enter license）,点击 use lic]]>
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://yoursite.com/2015/12/17/Hello%20World/"/>
    <id>http://yoursite.com/2015/12/17/Hello World/</id>
    <published>2015-12-17T09:38:22.581Z</published>
    <updated>2015-12-17T09:38:22.581Z</updated>
    <content type="html"><![CDATA[<p>终于有时间来写写了，离搭建好博客的时间一个有半个月了，期间发生了各种奇葩的事情（一个高中玩的好的朋友居然失踪了，各种联系，各种奔波，居然TMD自己玩失踪）。</p>
<p>开始还想写记录下来搭建博客的一下步骤的，现在过的太久，遇到的问题差不多忘记了（记忆力不好），这也是我搭建博客的主要原因之一，记录自己学习的知识点，以及工作中遇到的一些问题。</p>
<p>我主要就是参考下面的资料搭建了</p>
<ol>
<li><a href="http://blog.csdn.net/poem_of_sunshine/article/details/29369785" target="_blank" rel="external">独立博客搭建教程</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E6%98%BE%E7%A4%BA-feed-%E9%93%BE%E6%8E%A5" target="_blank" rel="external">hexo特性配置</a></li>
<li><a href="http://www.jianshu.com/p/73779eacb494" target="_blank" rel="external">hexo 静态博客使用指南</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>终于有时间来写写了，离搭建好博客的时间一个有半个月了，期间发生了各种奇葩的事情（一个高中玩的好的朋友居然失踪了，各种联系，各种奔波，居然TMD自己玩失踪）。</p>
<p>开始还想写记录下来搭建博客的一下步骤的，现在过的太久，遇到的问题差不多忘记了（记忆力不好），这也是我搭]]>
    </summary>
    
      <category term="随性" scheme="http://yoursite.com/tags/%E9%9A%8F%E6%80%A7/"/>
    
  </entry>
  
</feed>
