<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JDBC优化]]></title>
    <url>%2F2016%2F02%2F26%2Fjdbc%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[BeanUtils组件简介程序中对javabean的操作很频繁， 所以apache提供了一套开源的api，方便对javabean的操作！即BeanUtils组件。BeanUtils组件， 作用是简化javabean的操作！ 用户可以从www.apache.org下载BeanUtils组件，然后再在项目中引入jar文件！ 使用BenUtils组件： 引入commons-beanutils-1.8.3.jar核心包 引入日志支持包: commons-logging-1.1.3.jar 如果缺少日志jar文件，报错：12345java.lang.NoClassDefFoundError: org/apache/commons/logging/LogFactory at org.apache.commons.beanutils.ConvertUtilsBean.&lt;init&gt;(ConvertUtilsBean.java:157) at org.apache.commons.beanutils.BeanUtilsBean.&lt;init&gt;(BeanUtilsBean.java:117) at org.apache.commons.beanutils.BeanUtilsBean$1.initialValue(BeanUtilsBean.java:68) at 实例, 基本用法方法1： 对象属性的拷贝BeanUtils.copyProperty(admin, &quot;userName&quot;, &quot;jack&quot;);BeanUtils.setProperty(admin, &quot;age&quot;, 18);方法2： 对象的拷贝BeanUtils.copyProperties(newAdmin, admin);方法3： map数据拷贝到javabean中【注意：map中的key要与javabean的属性名称一致】BeanUtils.populate(adminMap, map); 1234567891011121314151617181920212223242526272829//1. 对javabean的基本操作 @Test public void test1() throws Exception &#123; // a. 基本操作 Admin admin = new Admin();// admin.setUserName("Jack");// admin.setPwd("999"); // b. BeanUtils组件实现对象属性的拷贝 BeanUtils.copyProperty(admin, "userName", "jack"); BeanUtils.setProperty(admin, "age", 18); // 总结1： 对于基本数据类型，会自动进行类型转换! // c. 对象的拷贝 Admin newAdmin = new Admin(); BeanUtils.copyProperties(newAdmin, admin); // d. map数据，拷贝到对象中 Admin adminMap = new Admin(); Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put("userName", "Jerry"); map.put("age", 29); // 注意：map中的key要与javabean的属性名称一致 BeanUtils.populate(adminMap, map); // 测试 System.out.println(adminMap.getUserName()); System.out.println(adminMap.getAge()); &#125; 实例, 日期类型的拷贝需要注册日期类型转换器，2种方式参见下面代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class App &#123; //1. 对javabean的基本操作 @Test public void test1() throws Exception &#123; // a. 基本操作 Admin admin = new Admin(); //admin.setUserName("Jack"); //admin.setPwd("999"); // b. BeanUtils组件实现对象属性的拷贝 BeanUtils.copyProperty(admin, "userName", "jack"); BeanUtils.setProperty(admin, "age", 18); // 总结1： 对于基本数据类型，会自动进行类型转换! // c. 对象的拷贝 Admin newAdmin = new Admin(); BeanUtils.copyProperties(newAdmin, admin); // d. map数据，拷贝到对象中 Admin adminMap = new Admin(); Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put("userName", "Jerry"); map.put("age", 29); // 注意：map中的key要与javabean的属性名称一致 BeanUtils.populate(adminMap, map); // 测试 System.out.println(adminMap.getUserName()); System.out.println(adminMap.getAge()); &#125; //2. 自定义日期类型转换器 @Test public void test2() throws Exception &#123; // 模拟表单数据 String name = "jack"; String age = "20"; String birth = " "; // 对象 Admin admin = new Admin(); // 注册日期类型转换器：1， 自定义的方式 ConvertUtils.register(new Converter() &#123; // 转换的内部实现方法，需要重写 @Override public Object convert(Class type, Object value) &#123; // 判断 if (type != Date.class) &#123; return null; &#125; if (value == null || "".equals(value.toString().trim())) &#123; return null; &#125; try &#123; // 字符串转换为日期 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); return sdf.parse(value.toString()); &#125; catch (ParseException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;,Date.class); // 把表单提交的数据，封装到对象中 BeanUtils.copyProperty(admin, "userName", name); BeanUtils.copyProperty(admin, "age", age); BeanUtils.copyProperty(admin, "birth", birth); //------ 测试------ System.out.println(admin); &#125; //2. 使用提供的日期类型转换器工具类 @Test public void test3() throws Exception &#123; // 模拟表单数据 String name = "jack"; String age = "20"; String birth = null; // 对象 Admin admin = new Admin(); // 注册日期类型转换器：2， 使用组件提供的转换器工具类 ConvertUtils.register(new DateLocaleConverter(), Date.class); // 把表单提交的数据，封装到对象中 BeanUtils.copyProperty(admin, "userName", name); BeanUtils.copyProperty(admin, "age", age); BeanUtils.copyProperty(admin, "birth", birth); //------ 测试------ System.out.println(admin); &#125;&#125; 应用1234567891011121314151617181920212223242526272829303132333435363738394041public class WebUtils &#123; @Deprecated public static &lt;T&gt; T copyToBean_old(HttpServletRequest request, Class&lt;T&gt; clazz) &#123; try &#123; // 创建对象 T t = clazz.newInstance(); // 获取所有的表单元素的名称 Enumeration&lt;String&gt; enums = request.getParameterNames(); // 遍历 while (enums.hasMoreElements()) &#123; // 获取表单元素的名称:&lt;input type="password" name="pwd"/&gt; String name = enums.nextElement(); // pwd // 获取名称对应的值 String value = request.getParameter(name); // 把指定属性名称对应的值进行拷贝 BeanUtils.copyProperty(t, name, value); &#125; return t; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 处理请求数据的封装 */ public static &lt;T&gt; T copyToBean(HttpServletRequest request, Class&lt;T&gt; clazz) &#123; try &#123; // （注册日期类型转换器） // 创建对象 T t = clazz.newInstance(); BeanUtils.populate(t, request.getParameterMap()); return t; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 元数据 在jdbc中获取数据库的定义，例如：数据库、表、列的定义信息。就用到元数据。 在jdbc中可以使用： 数据库元数据、参数元数据、结果集元数据 (元数据定义相关api， ..MetaData) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class App &#123; //1. 数据库元数据 @Test public void testDB() throws Exception &#123; // 获取连接 Connection conn = JdbcUtil.getConnection(); // 获取数据库元数据 DatabaseMetaData metaData = conn.getMetaData();// alt + shift + L 快速获取方法返回值 System.out.println(metaData.getUserName()); System.out.println(metaData.getURL()); System.out.println(metaData.getDatabaseProductName()); &#125; //2. 参数元数据 @Test public void testParams() throws Exception &#123; // 获取连接 Connection conn = JdbcUtil.getConnection(); // SQL String sql = "select * from dept where deptid=? and deptName=?"; // Object[] values = &#123;"tom","888"&#125;; PreparedStatement pstmt = conn.prepareStatement(sql); // 参数元数据 ParameterMetaData p_metaDate = pstmt.getParameterMetaData(); // 获取参数的个数 int count = p_metaDate.getParameterCount(); // 测试 System.out.println(count); &#125; // 3. 结果集元数据 @Test public void testRs() throws Exception &#123; String sql = "select * from dept "; // 获取连接 Connection conn = JdbcUtil.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql); ResultSet rs = pstmt.executeQuery(); // 得到结果集元数据(目标：通过结果集元数据，得到列的名称) ResultSetMetaData rs_metaData = rs.getMetaData(); // 迭代每一行结果 while (rs.next()) &#123; // 1. 获取列的个数 int count = rs_metaData.getColumnCount(); // 2. 遍历，获取每一列的列的名称 for (int i=0; i&lt;count; i++) &#123; // 得到列的名称 String columnName = rs_metaData.getColumnName(i + 1); // 获取每一行的每一列的值 Object columnValue = rs.getObject(columnName); // 测试 System.out.print(columnName + "=" + columnValue + ","); &#125; System.out.println(); &#125; &#125;&#125; Dao操作的抽取, BaseDaoDao操作通用的步骤： 写SQL语句 获取连接 创建stmt 执行sql 更新 查询 关闭/异常 通过的dao, 更新String sql = “select * from admin”;String sql = “select * from admin where id=? And pwd =?”;public void update(String sql, Object[] paramValues); 查询String sql = “select * from admin”;String sql = “select * from admin where id=? And pwd =?”;// 传入的什么类型的对象，就封装为什么类型// 要求： 列的名称，要与指定类型的对象的属性名称一样Public List&lt;T&gt; query (String sql , Object[] paramValues , Class&lt;T&gt; clazz);T t; // 对象赋值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/** * 通用的dao，自己写的所有的dao都继承此类; * 此类定义了2个通用的方法： * 1. 更新 * 2. 查询 * @author Jie.Yuan * */public class BaseDao &#123; // 初始化参数 private Connection con; private PreparedStatement pstmt; private ResultSet rs; /** * 更新的通用方法 * @param sql 更新的sql语句(update/insert/delete) * @param paramsValue sql语句中占位符对应的值(如果没有占位符，传入null) */ public void update(String sql,Object[] paramsValue)&#123; try &#123; // 获取连接 con = JdbcUtil.getConnection(); // 创建执行命令的stmt对象 pstmt = con.prepareStatement(sql); // 参数元数据： 得到占位符参数的个数 int count = pstmt.getParameterMetaData().getParameterCount(); // 设置占位符参数的值 if (paramsValue != null &amp;&amp; paramsValue.length &gt; 0) &#123; // 循环给参数赋值 for(int i=0;i&lt;count;i++) &#123; pstmt.setObject(i+1, paramsValue[i]); &#125; &#125; // 执行更新 pstmt.executeUpdate(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; JdbcUtil.closeAll(con, pstmt, null); &#125; &#125; /** * 查询的通用方法 * @param sql * @param paramsValue */ public &lt;T&gt; List&lt;T&gt; query(String sql, Object[] paramsValue,Class&lt;T&gt; clazz)&#123; try &#123; // 返回的集合 List&lt;T&gt; list = new ArrayList&lt;T&gt;(); // 对象 T t = null; // 1. 获取连接 con = JdbcUtil.getConnection(); // 2. 创建stmt对象 pstmt = con.prepareStatement(sql); // 3. 获取占位符参数的个数， 并设置每个参数的值 int count = pstmt.getParameterMetaData().getParameterCount(); if (paramsValue != null &amp;&amp; paramsValue.length &gt; 0) &#123; for (int i=0; i&lt;paramsValue.length; i++) &#123; pstmt.setObject(i+1, paramsValue[i]); &#125; &#125; // 4. 执行查询 rs = pstmt.executeQuery(); // 5. 获取结果集元数据 ResultSetMetaData rsmd = rs.getMetaData(); // ---&gt; 获取列的个数 int columnCount = rsmd.getColumnCount(); // 6. 遍历rs while (rs.next()) &#123; // 要封装的对象 t = clazz.newInstance(); // 7. 遍历每一行的每一列, 封装数据 for (int i=0; i&lt;columnCount; i++) &#123; // 获取每一列的列名称 String columnName = rsmd.getColumnName(i + 1); // 获取每一列的列名称, 对应的值 Object value = rs.getObject(columnName); // 封装： 设置到t对象的属性中 【BeanUtils组件】 BeanUtils.copyProperty(t, columnName, value); &#125; // 把封装完毕的对象，添加到list集合中 list.add(t); &#125; return list; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; JdbcUtil.closeAll(con, pstmt, rs); &#125; &#125;&#125;public class AdminDao extends BaseDao &#123; // 删除 public void delete(int id) &#123; String sql = "delete from admin where id=?"; Object[] paramsValue = &#123;id&#125;; super.update(sql, paramsValue); &#125; // 插入 public void save(Admin admin) &#123; String sql = "insert into admin (userName,pwd) values (?,?)"; Object[] paramsValue = &#123;admin.getUserName(),admin.getPwd()&#125;; super.update(sql, paramsValue); &#125; // 查询全部 public List&lt;Admin&gt; getAll()&#123; String sql = "select * from admin"; List&lt;Admin&gt; list = super.query(sql, null, Admin.class); return list; &#125; // 根据条件查询(主键) public Admin findById(int id)&#123; String sql = "select * from admin where id=?"; List&lt;Admin&gt; list = super.query(sql, new Object[]&#123;id&#125;, Admin.class); return (list!=null&amp;&amp;list.size()&gt;0) ? list.get(0) : null; &#125; &#125; DbUtils组件commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。因此dbutils成为很多不喜欢hibernate的公司的首选。 DbUtils组件 简化jdbc操作 下载组件，引入jar文件 : commons-dbutils-1.6.jar 实例|– DbUtils 关闭资源、加载驱动|– QueryRunner 组件的核心工具类：定义了所有的与数据库操作的方法(查询、更新) Int update(Connection conn, String sql, Object param); 执行更新带一个占位符的sqlInt update(Connection conn, String sql, Object… param); 执行更新带多个占位符的sqlInt[] batch(Connection conn, String sql, Object[][] params) 批处理T query(Connection conn ,String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) 查询方法 Int update( String sql, Object param);Int update( String sql, Object… param);Int[] batch( String sql, Object[][] params)注意： 如果调用DbUtils组件的操作数据库方法，没有传入连接对象，那么在实例化QueryRunner对象的时候需要传入数据源对象： QueryRunner qr = new QueryRunner(ds); DbUtils提供的封装结果的一些对象： BeanHandler: 查询返回单个对象 BeanListHandler: 查询返回list集合，集合元素是指定的对象 ArrayHandler, 查询返回结果记录的第一行，封装对对象数组, 即返回：Object[] ArrayListHandler, 把查询的每一行都封装为对象数组，再添加到list集合中 ScalarHandler 查询返回结果记录的第一行的第一列 (在聚合函数统计的时候用) MapHandler 查询返回结果的第一条记录封装为map]]></content>
      <categories>
        <category>jdbc的相关操作</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdbc基础]]></title>
    <url>%2F2016%2F02%2F03%2Fjdbc%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[jdbc入门使用java代码（程序）发送sql语句的技术，就是jdbc技术！！！！ 使用jdbc发送sql前提登录数据库服务器（连接数据库服务器） 数据库的IP地址 端口 数据库用户名 密码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * jdbc连接数据库 * @author APPle * */public class Demo1 &#123; //连接数据库的URL private String url = "jdbc:mysql://localhost:3306/day17"; // jdbc协议:数据库子协议:主机:端口/连接的数据库 // private String user = "root";//用户名 private String password = "root";//密码 /** * 第一种方法 * @throws Exception */ @Test public void test1() throws Exception&#123; //1.创建驱动程序类对象 Driver driver = new com.mysql.jdbc.Driver(); //新版本 //Driver driver = new org.gjt.mm.mysql.Driver(); //旧版本 //设置用户名和密码 Properties props = new Properties(); props.setProperty("user", user); props.setProperty("password", password); //2.连接数据库，返回连接对象 Connection conn = driver.connect(url, props); System.out.println(conn); &#125; /** * 使用驱动管理器类连接数据库(注册了两次，没必要) * @throws Exception */ @Test public void test2() throws Exception&#123; Driver driver = new com.mysql.jdbc.Driver(); //Driver driver2 = new com.oracle.jdbc.Driver(); //1.注册驱动程序(可以注册多个驱动程序) DriverManager.registerDriver(driver); //DriverManager.registerDriver(driver2); //2.连接到具体的数据库 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); &#125; /** * （推荐使用这种方式连接数据库） * 推荐使用加载驱动程序类 来 注册驱动程序 * @throws Exception */ @Test public void test3() throws Exception&#123; //Driver driver = new com.mysql.jdbc.Driver(); //通过得到字节码对象的方式加载静态代码块，从而注册驱动程序 Class.forName("com.mysql.jdbc.Driver"); //Driver driver2 = new com.oracle.jdbc.Driver(); //1.注册驱动程序(可以注册多个驱动程序) //DriverManager.registerDriver(driver); //DriverManager.registerDriver(driver2); //2.连接到具体的数据库 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); &#125;&#125; JDBC接口核心的APIjava.sql.* 和 javax.sql.* |- Driver接口： 表示java驱动程序接口。所有的具体的数据库厂商要来实现此接口。 |- connect(url, properties): 连接数据库的方法。 url: 连接数据库的URL URL语法： jdbc协议:数据库子协议://主机:端口/数据库 ser： 数据库的用户名 password： 数据库用户密码|- DriverManager类： 驱动管理器类，用于管理所有注册的驱动程序 |-registerDriver(driver) : 注册驱动类对象 |-Connection getConnection(url,user,password); 获取连接对象 |- Connection接口： 表示java程序和数据库的连接对象。 |- Statement createStatement() ： 创建Statement对象 |- PreparedStatement prepareStatement(String sql) 创建PreparedStatement对象 |- CallableStatement prepareCall(String sql) 创建CallableStatement对象 |- Statement接口： 用于执行静态的sql语句 |- int executeUpdate(String sql) ： 执行静态的更新sql语句（DDL，DML） |- ResultSet executeQuery(String sql) ：执行的静态的查询sql语句（DQL） |-PreparedStatement接口：用于执行预编译sql语句 |- int executeUpdate() ： 执行预编译的更新sql语句（DDL，DML） |-ResultSet executeQuery() ： 执行预编译的查询sql语句（DQL） |-CallableStatement接口：用于执行存储过程的sql语句（call xxx） |-ResultSet executeQuery() ： 调用存储过程的方法 |- ResultSet接口：用于封装查询出来的数据 |- boolean next() ： 将光标移动到下一行 |-getXX() : 获取列的值 使用Statement执行sql语句执行DDL语句12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 执行DDL语句(创建表) */ @Test public void test1()&#123; Statement stmt = null; Connection conn = null; try &#123; //1.驱动注册程序 Class.forName("com.mysql.jdbc.Driver"); //2.获取连接对象 conn = DriverManager.getConnection(url, user, password); //3.创建Statement stmt = conn.createStatement(); //4.准备sql String sql = "CREATE TABLE student(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20),gender VARCHAR(2))"; //5.发送sql语句，执行sql语句,得到返回结果 int count = stmt.executeUpdate(sql); //6.输出 System.out.println("影响了"+count+"行！"); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; finally&#123; //7.关闭连接(顺序:后打开的先关闭) if(stmt!=null) try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; if(conn!=null) try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; &#125; 执行DML语句123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164/** * 使用Statement执行DML语句 * @author APPle * */public class Demo2 &#123; private String url = "jdbc:mysql://localhost:3306/day17"; private String user = "root"; private String password = "root"; /** * 增加 */ @Test public void testInsert()&#123; Connection conn = null; Statement stmt = null; try &#123; //通过工具类获取连接对象 conn = JdbcUtil.getConnection(); //3.创建Statement对象 stmt = conn.createStatement(); //4.sql语句 String sql = "INSERT INTO student(NAME,gender) VALUES('李四','女')"; //5.执行sql int count = stmt.executeUpdate(sql); System.out.println("影响了"+count+"行"); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; finally&#123; //关闭资源 /*if(stmt!=null) try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; if(conn!=null) try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125;*/ JdbcUtil.close(conn, stmt); &#125; &#125; /** * 修改 */ @Test public void testUpdate()&#123; Connection conn = null; Statement stmt = null; //模拟用户输入 String name = "陈六"; int id = 3; try &#123; /*//1.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //2.获取连接对象 conn = DriverManager.getConnection(url, user, password);*/ //通过工具类获取连接对象 conn = JdbcUtil.getConnection(); //3.创建Statement对象 stmt = conn.createStatement(); //4.sql语句 String sql = "UPDATE student SET NAME='"+name+"' WHERE id="+id+""; System.out.println(sql); //5.执行sql int count = stmt.executeUpdate(sql); System.out.println("影响了"+count+"行"); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; finally&#123; //关闭资源 /*if(stmt!=null) try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; if(conn!=null) try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125;*/ JdbcUtil.close(conn, stmt); &#125; &#125; /** * 删除 */ @Test public void testDelete()&#123; Connection conn = null; Statement stmt = null; //模拟用户输入 int id = 3; try &#123; /*//1.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //2.获取连接对象 conn = DriverManager.getConnection(url, user, password);*/ //通过工具类获取连接对象 conn = JdbcUtil.getConnection(); //3.创建Statement对象 stmt = conn.createStatement(); //4.sql语句 String sql = "DELETE FROM student WHERE id="+id+""; System.out.println(sql); //5.执行sql int count = stmt.executeUpdate(sql); System.out.println("影响了"+count+"行"); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; finally&#123; //关闭资源 /*if(stmt!=null) try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; if(conn!=null) try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125;*/ JdbcUtil.close(conn, stmt); &#125; &#125;&#125; 执行DQL语句1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 使用Statement执行DQL语句（查询操作） * @author APPle */public class Demo3 &#123; @Test public void test1()&#123; Connection conn = null; Statement stmt = null; try&#123; //获取连接 conn = JdbcUtil.getConnection(); //创建Statement stmt = conn.createStatement(); //准备sql String sql = "SELECT * FROM student"; //执行sql ResultSet rs = stmt.executeQuery(sql); //移动光标 /*boolean flag = rs.next(); flag = rs.next(); flag = rs.next(); if(flag)&#123; //取出列值 //索引 int id = rs.getInt(1); String name = rs.getString(2); String gender = rs.getString(3); System.out.println(id+","+name+","+gender); //列名称 int id = rs.getInt("id"); String name = rs.getString("name"); String gender = rs.getString("gender"); System.out.println(id+","+name+","+gender); &#125;*/ //遍历结果 while(rs.next())&#123; int id = rs.getInt("id"); String name = rs.getString("name"); String gender = rs.getString("gender"); System.out.println(id+","+name+","+gender); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); throw new RuntimeException(e); &#125;finally&#123; JdbcUtil.close(conn, stmt); &#125; &#125;&#125; 使用PreparedStatement执行sql语句123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150public class Demo1 &#123; /** * 增加 */ @Test public void testInsert() &#123; Connection conn = null; PreparedStatement stmt = null; try &#123; //1.获取连接 conn = JdbcUtil.getConnection(); //2.准备预编译的sql String sql = "INSERT INTO student(NAME,gender) VALUES(?,?)"; //?表示一个参数的占位符 //3.执行预编译sql语句(检查语法) stmt = conn.prepareStatement(sql); //4.设置参数值 /** * 参数一： 参数位置 从1开始 */ stmt.setString(1, "李四"); stmt.setString(2, "男"); //5.发送参数，执行sql int count = stmt.executeUpdate(); System.out.println("影响了"+count+"行"); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; finally &#123; JdbcUtil.close(conn, stmt); &#125; &#125; /** * 修改 */ @Test public void testUpdate() &#123; Connection conn = null; PreparedStatement stmt = null; try &#123; //1.获取连接 conn = JdbcUtil.getConnection(); //2.准备预编译的sql String sql = "UPDATE student SET NAME=? WHERE id=?"; //?表示一个参数的占位符 //3.执行预编译sql语句(检查语法) stmt = conn.prepareStatement(sql); //4.设置参数值 /** * 参数一： 参数位置 从1开始 */ stmt.setString(1, "王五"); stmt.setInt(2, 9); //5.发送参数，执行sql int count = stmt.executeUpdate(); System.out.println("影响了"+count+"行"); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; finally &#123; JdbcUtil.close(conn, stmt); &#125; &#125; /** * 删除 */ @Test public void testDelete() &#123; Connection conn = null; PreparedStatement stmt = null; try &#123; //1.获取连接 conn = JdbcUtil.getConnection(); //2.准备预编译的sql String sql = "DELETE FROM student WHERE id=?"; //?表示一个参数的占位符 //3.执行预编译sql语句(检查语法) stmt = conn.prepareStatement(sql); //4.设置参数值 /** * 参数一： 参数位置 从1开始 */ stmt.setInt(1, 9); //5.发送参数，执行sql int count = stmt.executeUpdate(); System.out.println("影响了"+count+"行"); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; finally &#123; JdbcUtil.close(conn, stmt); &#125; &#125; /** * 查询 */ @Test public void testQuery() &#123; Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try &#123; //1.获取连接 conn = JdbcUtil.getConnection(); //2.准备预编译的sql String sql = "SELECT * FROM student"; //3.预编译 stmt = conn.prepareStatement(sql); //4.执行sql rs = stmt.executeQuery(); //5.遍历rs while(rs.next())&#123; int id = rs.getInt("id"); String name = rs.getString("name"); String gender = rs.getString("gender"); System.out.println(id+","+name+","+gender); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; finally &#123; //关闭资源 JdbcUtil.close(conn,stmt,rs); &#125; &#125;&#125; PreparedStatement vs Statment 语法不同：PreparedStatement可以使用预编译的sql，而Statment只能使用静态的sql 效率不同： PreparedStatement可以使用sql缓存区，效率比Statment高 安全性不同： PreparedStatement可以有效防止sql注入，而Statment不能防止sql注入。 推荐使用PreparedStatement CallableStatement执行存储过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 使用CablleStatement调用存储过程 * @author APPle * */public class Demo1 &#123; /** * 调用带有输入参数的存储过程 * CALL pro_findById(4); */ @Test public void test1()&#123; Connection conn = null; CallableStatement stmt = null; ResultSet rs = null; try &#123; //获取连接 conn = JdbcUtil.getConnection(); //准备sql String sql = "CALL pro_findById(?)"; //可以执行预编译的sql //预编译 stmt = conn.prepareCall(sql); //设置输入参数 stmt.setInt(1, 6); //发送参数 rs = stmt.executeQuery(); //注意： 所有调用存储过程的sql语句都是使用executeQuery方法执行！！！ //遍历结果 while(rs.next())&#123; int id = rs.getInt("id"); String name = rs.getString("name"); String gender = rs.getString("gender"); System.out.println(id+","+name+","+gender); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; finally &#123; JdbcUtil.close(conn, stmt ,rs); &#125; &#125; /** * 执行带有输出参数的存储过程 * CALL pro_findById2(5,@NAME); */ @Test public void test2()&#123; Connection conn = null; CallableStatement stmt = null; ResultSet rs = null; try &#123; //获取连接 conn = JdbcUtil.getConnection(); //准备sql String sql = "CALL pro_findById2(?,?)"; //第一个？是输入参数，第二个？是输出参数 //预编译 stmt = conn.prepareCall(sql); //设置输入参数 stmt.setInt(1, 6); //设置输出参数(注册输出参数) /** * 参数一： 参数位置 * 参数二： 存储过程中的输出参数的jdbc类型 VARCHAR(20) */ stmt.registerOutParameter(2, java.sql.Types.VARCHAR); //发送参数，执行 stmt.executeQuery(); //结果不是返回到结果集中，而是返回到输出参数中 //得到输出参数的值 /** * 索引值： 预编译sql中的输出参数的位置 */ String result = stmt.getString(2); //getXX方法专门用于获取存储过程中的输出参数 System.out.println(result); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; finally &#123; JdbcUtil.close(conn, stmt ,rs); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql加强]]></title>
    <url>%2F2016%2F02%2F01%2Fmysql%E5%8A%A0%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[数据约束对用户操作表的数据进行约束 默认值作用： 当用户对使用默认值的字段不插入值的时候，就使用默认值。注意： 对默认值字段插入null是可以的。 对默认值字段可以插入非null – 1.1 默认值CREATE TABLE student( id INT, NAME VARCHAR(20), address VARCHAR(20) DEFAULT ‘广州天河’ – 默认值)DROP TABLE student;– 当字段没有插入值的时候，mysql自动给该字段分配默认值INSERT INTO student(id,NAME) VALUES(1,’张三’);– 注意：默认值的字段允许为nullINSERT INTO student(id,NAME,address) VALUE(2,’李四’,NULL);INSERT INTO student(id,NAME,address) VALUE(3,’王五’,’广州番禺’); 非空作用：限制字段必须赋值注意： 非空字符必须赋值非空字符不能赋null – 1.2 非空– 需求： gender字段必须有值（不为null）CREATE TABLE student( id INT, NAME VARCHAR(20), gender VARCHAR(2) NOT NULL – 非空)– 非空字段必须赋值INSERT INTO student(id,NAME) VALUES(1,’李四’);– 非空字符不能插入nullINSERT INTO student(id,NAME,gender) VALUES(1,’李四’,NULL); 唯一作用：对字段的值不能重复注意： 唯一字段可以插入null唯一字段可以插入多个null – 1.3 唯一CREATE TABLE student( id INT UNIQUE, – 唯一 NAME VARCHAR(20))INSERT INTO student(id,NAME) VALUES(1,’zs’);INSERT INTO student(id,NAME) VALUES(1,’lisi’); – ERROR 1062 (23000): Duplicate entry ‘1’ for key ‘id’INSERT INTO student(id,NAME) VALUES(2,’lisi’); 主键作用： 非空+唯一注意： 通常情况下，每张表都会设置一个主键字段。用于标记表中的每条记录的唯一性。建议不要选择表的包含业务含义的字段作为主键，建议给每张表独立设计一个非业务含义的id字段。 1.4 主键（非空+唯一）DROP TABLE student;CREATE TABLE student( id INT PRIMARY KEY, – 主键 NAME VARCHAR(20))INSERT INTO student(id,NAME) VALUES(1,’张三’);INSERT INTO student(id,NAME) VALUES(2,’张三’);– INSERT INTO student(id,NAME) VALUES(1,’李四’); – 违反唯一约束： Duplicate entry ‘1’ for key ‘PRIMARY’– insert into student(name) value(‘李四’); – 违反非空约束： ERROR 1048 (23000): Column ‘id’ cannot be null 自增长作用： 自动递增 – 1.5 自增长CREATE TABLE student( id INT(4) ZEROFILL PRIMARY KEY AUTO_INCREMENT, – 自增长，从0开始 ZEROFILL 零填充 NAME VARCHAR(20))– 自增长字段可以不赋值，自动递增INSERT INTO student(NAME) VALUES(‘张三’);INSERT INTO student(NAME) VALUES(‘李四’);INSERT INTO student(NAME) VALUES(‘王五’);SELECT * FROM student;– 不能影响自增长约束DELETE FROM student;– 可以影响自增长约束TRUNCATE TABLE student; 外键作用：约束两种表的数据出现两种表的情况： 解决数据冗余高问题： 独立出一张表例如：员工表和部门表问题出现：在插入员工表数据的时候，员工表的部门ID字段可以随便插入！！！使用外键约束：约束插入员工表的部门ID字段值解决办法： 在员工表的部门ID字段添加一个外键约束– 部门表（主表）CREATE TABLE dept( id INT PRIMARY KEY, deptName VARCHAR(20))– 修改员工表（副表/从表）CREATE TABLE employee( id INT PRIMARY KEY, empName VARCHAR(20), deptId INT,– 把部门名称改为部门ID – 声明一个外键约束 CONSTRAINT emlyee_dept_fk FOREIGN KEY(deptId) REFERENCES dept(id) –外键名称 外键 参考表(参考字段)) 注意：1）被约束的表称为副表，约束别人的表称为主表，外键设置在副表上的！！！2）主表的参考字段通用为主键！3）添加数据： 先添加主表，再添加副表4）修改数据： 先修改副表，再修改主表5）删除数据： 先删除副表，再删除主表 – 1.6 外键约束– 员工表CREATE TABLE employee( id INT PRIMARY KEY, empName VARCHAR(20), deptName VARCHAR(20) – 部门名称)INSERT INTO employee VALUES(1,’张三’,’软件开发部’);INSERT INTO employee VALUES(2,’李四’,’软件开发部’);INSERT INTO employee VALUES(3,’王五’,’应用维护部’); SELECT * FROM employee; – 添加员工，部门名称的数据冗余高INSERT INTO employee VALUES(4,’陈六’,’软件开发部’); – 解决数据冗余高的问题：给冗余的字段放到一张独立表中– 独立设计一张部门表CREATE TABLE dept( id INT PRIMARY KEY, deptName VARCHAR(20)) DROP TABLE employee; – 修改员工表CREATE TABLE employee( id INT PRIMARY KEY, empName VARCHAR(20), deptId INT,– 把部门名称改为部门ID – 声明一个外键约束 CONSTRAINT emlyee_dept_fk FOREIGN KEY(deptId) REFERENCES dept(id) ON UPDATE CASCADE ON DELETE CASCADE – ON CASCADE UPDATE ：级联修改 – 外键名称 外键 参考表(参考字段)) INSERT INTO dept(id,deptName) VALUES(1,’软件开发部’);INSERT INTO dept(id,deptName) VALUES(2,’应用维护部’);INSERT INTO dept(id,deptName) VALUES(3,’秘书部’);INSERT INTO employee VALUES(1,’张三’,1);INSERT INTO employee VALUES(2,’李四’,1);INSERT INTO employee VALUES(3,’王五’,2);INSERT INTO employee VALUES(4,’陈六’,3); – 问题: 该记录业务上不合法，员工插入了一个不存在的部门数据INSERT INTO employee VALUES(5,’陈六’,4); – 违反外键约束： Cannot add or update a child row: a foreign key constraint fails (day16.employee, CONSTRAINT emlyee_dept_fk FOREIGN KEY (deptId) REFERENCES dept (id)) – 1）当有了外键约束，添加数据的顺序： 先添加主表，再添加副表数据– 2）当有了外键约束，修改数据的顺序： 先修改副表，再修改主表数据– 3）当有了外键约束，删除数据的顺序： 先删除副表，再删除主表数据– 修改部门(不能直接修改主表)UPDATE dept SET id=4 WHERE id=3;– 先修改员工表UPDATE employee SET deptId=2 WHERE id=4;– 删除部门DELETE FROM dept WHERE id=2;– 先删除员工表DELETE FROM employee WHERE deptId=2; SELECT FROM dept;SELECT FROM employee; 级联操作问题： 当有了外键约束的时候，必须先修改或删除副表中的所有关联数据，才能修改或删除主表！但是，我们希望直接修改或删除主表数据，从而影响副表数据。可以使用级联操作实现！！！ 级联修改： ON UPDATE CASCADE级联删除： ON DELETE CASCADE CREATE TABLE employee( id INT PRIMARY KEY, empName VARCHAR(20), deptId INT,– 把部门名称改为部门ID – 声明一个外键约束 CONSTRAINT emlyee_dept_fk FOREIGN KEY(deptId) REFERENCES dept(id) ON UPDATE CASCADE ON DELETE CASCADE – ON CASCADE UPDATE ：级联修改 – 外键名称 外键 参考表(参考字段))注意： 级联操作必须在外键基础上使用– 级联修改（修改）– 直接修改部门UPDATE dept SET id=5 WHERE id=4;– 级联删除– 直接删除部门DELETE FROM dept WHERE id=1; 数据库设计三大范式设计原则： 建议设计的表尽量遵守三大范式。 第一范式：要求表的每个字段必须是不可分割的独立单元 student : name – 违反第一范式 张小名|狗娃 sutdent ：name old_name –符合第一范式 张小名 狗娃 第二范式：在第一范式的基础上，要求每张表只表达一个意思。表的每个字段都和表的主键有依赖。 employee（员工）: 员工编号 员工姓名 部门名称 订单名称 –违反第二范式 员工表：员工编号 员工姓名 部门名称 订单表： 订单编号 订单名称 – 符合第二范式 第三范式：在第二范式基础，要求每张表的主键之外的其他字段都只能和主键有直接决定依赖关系。 员工表： 员工编号（主键） 员工姓名 部门编号 部门名 –符合第二范式，违反第三范式（数据冗余高） 员工表：员工编号（主键） 员工姓名 部门编号–符合第三范式（降低数据冗余） 部门表：部门编号 部门名 关联查询(多表查询) – **二、关联查询（多表查询）**—-– 需求：查询员工及其所在部门(显示员工姓名，部门名称) – 2.1 交叉连接查询（不推荐。产生笛卡尔乘积现象：4 * 4=16，有些是重复记录）SELECT empName,deptName FROM employee,dept;– 需求：查询员工及其所在部门(显示员工姓名，部门名称)– 多表查询规则：1）确定查询哪些表2）确定哪些哪些字段3）表与表之间连接条件 (规律：连接条件数量是表数量-1) – 2.2 内连接查询：只有满足条件的结果才会显示(使用最频繁) SELECT empName,deptName – 2）确定哪些哪些字段 FROM employee,dept – 1）确定查询哪些表 WHERE employee.deptId=dept.id – 3）表与表之间连接条件– 内连接的另一种语法SELECT empName,deptName FROM employee INNER JOIN dept ON employee.deptId=dept.id;– 使用别名SELECT e.empName,d.deptName FROM employee e INNER JOIN dept d ON e.deptId=d.id;– 需求： 查询每个部门的员工– 预期结果： – 软件开发部 张三 – 软件开发部 李四 – 应用维护部 王五 – 秘书部 陈六 – 总经办 null – 2.3 左[外]连接查询： 使用左边表的数据去匹配右边表的数据，如果符合连接条件的结果则显示，如果不符合连接条件则显示null – （注意： 左外连接：左表的数据一定会完成显示！）SELECT d.deptName,e.empName FROM dept d LEFT OUTER JOIN employee e ON d.id=e.deptId; – 2.4 右[外]连接查询: 使用右边表的数据去匹配左边表的数据，如果符合连接条件的结果则显示，如果不符合连接条件则显示null – （注意： 右外连接：右表的数据一定会完成显示！）SELECT d.deptName,e.empName FROM employee e RIGHT OUTER JOIN dept d ON d.id=e.deptId; – 2.5 自连接查询– 需求：查询员工及其上司– 预期结果： – 张三 null – 李四 张三 – 王五 李四 – 陈六 王五SELECT e.empName,b.empName FROM employee e LEFT OUTER JOIN employee b ON e.bossId=b.id; 存储过程存储过程，带有逻辑的sql语句之前的sql没有条件判断，没有循环存储过程带上流程控制语句（if while） 特点： 1）执行效率非常快！存储过程是在数据库的服务器端执行的！！！2）移植性很差！不同数据库的存储过程是不能移植。语法: – 创建存储过程DELIMITER $ – 声明存储过程的结束符CREATE PROCEDURE pro_test() –存储过程名称(参数列表)BEGIN – 开始– 可以写多个sql语句; – sql语句+流程控制 SELECT * FROM employee;END $ – 结束 结束符– 执行存储过程CALL pro_test(); – CALL 存储过程名称(参数);参数：IN： 表示输入参数，可以携带数据带存储过程中OUT： 表示输出参数，可以从存储过程中返回结果INOUT： 表示输入输出参数，既可以输入功能，也可以输出功能– **三、存储过程*-– 声明结束符– 创建存储过程DELIMITER $CREATE PROCEDURE pro_test()BEGIN – 可以写多个sql语句; SELECT * FROM employee;END $ – 执行存储过程CALL pro_test(); – 3.1 带有输入参数的存储过程– 需求：传入一个员工的id，查询员工信息DELIMITER $CREATE PROCEDURE pro_findById(IN eid INT) – IN: 输入参数BEGIN SELECT * FROM employee WHERE id=eid;END $ – 调用CALL pro_findById(4); – 3.2 带有输出参数的存储过程DELIMITER $CREATE PROCEDURE pro_testOut(OUT str VARCHAR(20)) – OUT：输出参数BEGIN – 给参数赋值 SET str=’helljava’;END $ – 删除存储过程DROP PROCEDURE pro_testOut;– 调用– 如何接受返回参数的值？？– mysql的变量*– 全局变量（内置变量）：mysql数据库内置的变量 （所有连接都起作用） – 查看所有全局变量： show variables – 查看某个全局变量： select @@变量名 – 修改全局变量： set 变量名=新值 – character_set_client: mysql服务器的接收数据的编码 – character_set_results：mysql服务器输出数据的编码 – 会话变量： 只存在于当前客户端与数据库服务器端的一次连接当中。如果连接断开，那么会话变量全部丢失！ – 定义会话变量: set @变量=值 – 查看会话变量： select @变量 – 局部变量： 在存储过程中使用的变量就叫局部变量。只要存储过程执行完毕，局部变量就丢失！！ – 1)定义一个会话变量name, 2)使用name会话变量接收存储过程的返回值CALL pro_testOut(@NAME);– 查看变量值SELECT @NAME; – 3.3 带有输入输出参数的存储过程DELIMITER $CREATE PROCEDURE pro_testInOut(INOUT n INT) – INOUT： 输入输出参数BEGIN – 查看变量 SELECT n; SET n =500;END $ – 调用SET @n=10; CALL pro_testInOut(@n); SELECT @n; – 3.4 带有条件判断的存储过程– 需求：输入一个整数，如果1，则返回“星期一”,如果2，返回“星期二”,如果3，返回“星期三”。其他数字，返回“错误输入”;DELIMITER $CREATE PROCEDURE pro_testIf(IN num INT,OUT str VARCHAR(20))BEGIN F num=1 THEN SET str=’星期一’; ELSEIF num=2 THEN SET str=’星期二’; ELSEIF num=3 THEN SET str=’星期三’; ELSE SET str=’输入错误’; END IF;END $ CALL pro_testIf(4,@str); SELECT @str; – 3.5 带有循环功能的存储过程– 需求： 输入一个整数，求和。例如，输入100，统计1-100的和DELIMITER $CREATE PROCEDURE pro_testWhile(IN num INT,OUT result INT)BEGIN – 定义一个局部变量 DECLARE i INT DEFAULT 1; DECLARE vsum INT DEFAULT 0; WHILE i&lt;=num DO SET vsum = vsum+i; SET i=i+1; END WHILE; SET result=vsum;END $ DROP PROCEDURE pro_testWhile; CALL pro_testWhile(100,@result); SELECT @result; USE day16; – 3.6 使用查询的结果赋值给变量（INTO）DELIMITER $CREATE PROCEDURE pro_findById2(IN eid INT,OUT vname VARCHAR(20) )BEGIN SELECT empName INTO vname FROM employee WHERE id=eid;END $ CALL pro_findById2(1,@NAME); SELECT @NAME; 触发器作用:当操作了某张表时，希望同时触发一些动作/行为，可以使用触发器完成！！ – 需求： 当向员工表插入一条记录时，希望mysql自动同时往日志表插入数据– 创建触发器(添加)CREATE TRIGGER tri_empAdd AFTER INSERT ON employee FOR EACH ROW – 当往员工表插入一条记录时 INSERT INTO test_log(content) VALUES(‘员工表插入了一条记录’); – 插入数据INSERT INTO employee(id,empName,deptId) VALUES(7,’扎古斯’,1);INSERT INTO employee(id,empName,deptId) VALUES(8,’扎古斯2’,1); – 创建触发器(修改)CREATE TRIGGER tri_empUpd AFTER UPDATE ON employee FOR EACH ROW – 当往员工表修改一条记录时 INSERT INTO test_log(content) VALUES(‘员工表修改了一条记录’); – 修改 UPDATE employee SET empName=’eric’ WHERE id=7; – 创建触发器(删除)CREATE TRIGGER tri_empDel AFTER DELETE ON employee FOR EACH ROW – 当往员工表删除一条记录时 INSERT INTO test_log(content) VALUES(‘员工表删除了一条记录’); – 删除 DELETE FROM employee WHERE id=7; mysql权限问题 – *五、mysql权限问题** – mysql数据库权限问题：root ：拥有所有权限（可以干任何事情） – 权限账户，只拥有部分权限（CURD）例如，只能操作某个数据库的某张表 – 如何修改mysql的用户密码？ – password: md5加密函数(单向加密) SELECT PASSWORD(‘root’); – *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B – mysql数据库，用户配置 : user表USE mysql; SELECT * FROM USER; – 修改密码UPDATE USER SET PASSWORD=PASSWORD(‘123456’) WHERE USER=’root’; – 分配权限账户GRANT SELECT ON day16.employee TO ‘eric’@’localhost’ IDENTIFIED BY ‘123456’;GRANT DELETE ON day16.employee TO ‘eric’@’localhost’ IDENTIFIED BY ‘123456’; 总结mysql基础 mysql存储结构： 数据库 -&gt; 表 -&gt; 数据 sql语句 管理数据库： 增加： create database 数据库 default character utf8; 删除： drop database 数据库; 修改： alter database 数据库 default character gbk; 查询： show databases / show create database 数据库; 管理表：选择数据库：use 数据库; 增加： create table 表(字段名1 字段类型,字段名2 字段类型……); 删除： drop table 表; 修改： 添加字段： alter table 表 add [column] 字段名 字段类型; 删除字段: alter table 表 drop [column] 字段名; 修改字段类型： alter table 表 modify 字段名 新的字段类型; 修改字段名称 ： alter table 表 change 旧字段名 新字段名 字段类型; 修改表名称： alter table 表 rename [to] 新表名;查询：show tables / desc student; 管理数据: 增加： insert into 表(字段1，字段2,。。。) -values(值1，值2.。。。。); 删除： delete from 表 where 条件; 修改： update 表 set 字段1=值1，字段2=值2…… where 条件;查询： 所有字段： select * from 表; 指定字段： select 字段1,字段2…. from 表; 指定别名： select 字段1 as 别名 from 表; 合并列： select (字段1+字段2) from 表; 去重： select distinct 字段 from 表; 条件查询： 逻辑条件 ：and(与) or（或）select * from 表 where 条件1 and/or 条件2 比较条件： &gt; &lt; &gt;= &lt;= = &lt;&gt; between and(在。。。之间)select * from 表 where servlet&gt;=90; 判空条件：判断null： is null / is not null判断空字符串： =’’ / &lt;&gt;’’ 模糊条件： like%: 替换任意个字符_: 替换一个字符 分页查询：limit 起始行,查询行数起始行从0开始 排序： order by 字段 asc/descasc: 正序，顺序desc：反序，倒序 分组查询：group by 字段 分组后筛选： having 条件 SQL语句的分类： DDL： 数据定义语言create / drop / alter DML：数据操作语句insert / delete /update / truncate DQL： 数据查询语言：select / show mysql加强 数据约束（表约束） 默认值： default 默认值 非空： not null 唯一： unique 主键： primary key （非空+唯一） 自增长： auto_increment 外键： foreign key 约束两种表 关联查询（多表查询） 交叉连接（产生笛卡尔积：原因：连接条件不足够） 表数量-1 内连接查询： inner join只有满足连接条件的数据才会显示！！！ 左【外】连接查询：left [outer] join左表的数据必须全部显示，用左表去匹配右表的数据，如果右表有符号条件的数据则显示符 合条件的数据；如果不符合条件，则显示null。 右【外】连接查询： right [outer] join右表的数据必须全部显示，用右表去匹配左表的数据，如果左表有符号条件的数据则显示符 合条件的数据；如果不符合条件，则显示null。 自连接查询 存储过程 创建存储过程语法delimeter 结束符号create procedure 名称(IN/OUT/INOUT 参数名称 参数类型)begin带逻辑的sql语句end 结束符号 调用存储过程CALL 存储过程名称(实际参数);]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql基础]]></title>
    <url>%2F2016%2F01%2F18%2Fmysql%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据库入门引入数据保存到内存：优点： 读写非常快缺点： 程序关闭导致数据丢失 数据保存到文件：优点： 数据可以永久保存缺点： 频繁地IO操作，效率不高！ 数据管理不方便。例如查询某个数据需要全部读取出来，再匹配。 数据保存到数据库软件：优点： 数据永久保存下来 数据管理非常方便。（例如查询非常快速和方便） 数据可以说是企业的灵魂！！ 什么是数据库软件数据库，俗称数据的仓库。方便管理数据的软件（或程序）。 市面上数据库软件Oracle，甲骨文公司的产品。 当前最流行应用最广泛的数据库软件。和java语言兼容非常好。适合中大型，中大应用。 SQL Server: 是微软公司的产品。window平台应用非常广泛。和c#，net平台兼容非常好。 DB2： IBM公司的产品。IBM服务器–&gt; UNIX -&gt; DB2- &gt; Websphere MySQL: 开源组织的产品。甲骨文公司的产品。免费！！！和java语言兼容非常好！适合中小企业，中小应用 关系型数据库。 MongoDB： 非关系型数据库。 先学mysql，后面再学oracle MySQL入门 到mysql官网下载。 安装mysql软件 使用 验证是否成功打开cmd -&gt; 输入 mysql -u root -p 回车 -&gt; 输入密码 回车C:\Users\APPle&gt;mysql -u root -pEnter password: **** Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.5.40 MySQL Community Server (GPL)Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type ‘help;’ or ‘\h’ for help. Type ‘\c’ to clear the current input statement.mysql&gt; 数据库管理查询所有数据库 mysql&gt; show databases;+——————–+| Database |+——————–+| information_schema | – mysql元数据，基础数据| mysql | –mysql配置数据库，其中包含用户信息。（用户名和密码，权限管理）| performance_schema | –mysql数据库软件的运行数据，日志信息，性能数据| test | –测试数据库。空的+——————–+4 rows in set (0.00 sec) 创建数据库 mysql&gt; create database day15 – 指定默认字符集创建数据库-&gt; default character set utf8-&gt; ;Query OK, 1 row affected (0.00 sec) 查看数据库的默认字符集 mysql&gt; show create database day15;+———-+—————————————————————-+| Database | Create Database |+———-+—————————————————————-+| day15 | CREATE DATABASE day15 /!40100 DEFAULT CHARACTER SET utf8 / |+———-+—————————————————————-+1 row in set (0.00 sec) 删除数据库 mysql&gt; drop database day15;Query OK, 0 rows affected (0.01 sec) 修改数据库 mysql&gt; alter database day15 default character set gbk;Query OK, 1 row affected (0.00 sec) 表管理选择数据库 查看所有表 mysql&gt; show tables;+—————–+| Tables_in_day15 |+—————–+| student |+—————–+1 row in set (0.00 sec) 创建表 mysql&gt; create table student( -&gt; sid int, -&gt; sname varchar(20), -&gt; sage int -&gt; );Query OK, 0 rows affected (0.01 sec) 查看表结构 mysql&gt; desc student;+——-+————-+——+—–+———+——-+| Field | Type | Null | Key | Default | Extra |+——-+————-+——+—–+———+——-+| sid | int(11) | YES | | NULL | || sname | varchar(20) | YES | | NULL | || sage | int(11) | YES | | NULL | |+——-+————-+——+—–+———+——-+3 rows in set (0.01 sec) 删除表 mysql&gt; drop table student;Query OK, 0 rows affected (0.01 sec) 修改表 添加字段 mysql&gt; alter table student add column sgender varchar(2);Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0 删除字段 mysql&gt; alter table student drop column sgender;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0 修改字段类型 mysql&gt; alter table student modify column remark varchar(100);Query OK, 0 rows affected (0.07 sec)Records: 0 Duplicates: 0 Warnings: 0 修改字段名称 mysql&gt; alter table student change column sgender gender varchar(2);Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0 修改表名称 mysql&gt; alter table student rename to teacher;Query OK, 0 rows affected (0.01 sec) 增删改数据 增加数据插入所有字段。一定依次按顺序插入INSERT INTO student VALUES(1,&#39;张三&#39;,&#39;男&#39;,20);注意不能少或多字段值INSERT INTO student VALUES(2,&#39;李四&#39;,&#39;女&#39;);插入部分字段INSERT INTO student(id,NAME) VALUES(2,&#39;李四&#39;); 修改数据修改所有数据（建议少用）UPDATE student SET gender=&#39;女&#39;;带条件的修改（推荐使用）UPDATE student SET gender=&#39;男&#39; WHERE id=1; 修改id为1的学生，修改性别为男修改多个字段,注意:SET 字段名=值,字段名=值,….UPDATE student SET gender=&#39;男&#39;,age=30 WHERE id=2; 删除数据删除所有数据（建议少用）DELETE FROM student;带条件的删除(推荐使用)DELETE FROM student WHERE id=2;另一种方式delete from: 可以全表删除1）可以带条件删除2）只能删除表的数据，不能删除表的约束3）使用delete from删除的数据可以回滚（事务）truncate table: 可以全表删除1）不能带条件删除2）即可以删除表的数据，也可以删除表的约束3）使用truncate table删除的数据不能回滚TRUNCATE TABLE student; 查询数据（重点）查询所有列SELECT * FROM student; 查询指定列SELECT id,NAME,gender FROM student; 查询时添加常量列 需求： 在查询student表时添加一个班级列，内容为“java就业班”SELECT id,NAME,gender,age,&#39;java就业班&#39; AS &#39;年级&#39; FROM student; 查询时合并列 需求： 查询每个学生的servlet和jsp的总成绩SELECT id,NAME,(servlet+jsp) AS &#39;总成绩&#39; FROM student;注意：合并列只能合并数值类型的字段SELECT id,(NAME+servlet) FROM student; 查询时去除重复记录 需求： 查询学生的性别 男 女SELECT DISTINCT gender FROM student;另一种语法SELECT DISTINCT(gender) FROM student;需求: 查询学生所在的地区SELECT DISTINCT address FROM student; 条件查询 逻辑条件： and(与) or(或) 需求： 查询id为2，且姓名为李四的学生SELECT * FROM student WHERE id=2 AND NAME=&#39;李四&#39;; -- 交集需求： 查询id为2，或姓名为张三的学生SELECT * FROM student WHERE id=2 OR NAME=&#39;张三&#39;; -- 并集 比较条件： &gt; &lt; &gt;= &lt;= = &lt;&gt;(不等于) between and (等价于&gt;= 且 &lt;=) 需求： 查询servlet成绩大于70分的学生SELECT * FROM student WHERE servlet&gt;70;需求： 查询jsp成绩大于等于75，且小于等于90分的学生SELECT * FROM student WHERE jsp&gt;=75 AND jsp&lt;=90;另一个语法SELECT * FROM student WHERE jsp BETWEEN 75 AND 90; -- (包前包后)SELECT * FROM student WHERE gender&lt;&gt;&#39;男&#39;; 判空条件(null 空字符串)： is null / is not null / =’’ / &lt;&gt;’’ 需求： 查询地址为空的学生（包括null和空字符串）null vs 空字符串null：表示没有值空字符串：有值的！判断nullSELECT * FROM student WHERE address IS NULL ;判断空字符串SELECT * FROM student WHERE address=&#39;&#39;;SELECT * FROM student WHERE address IS NULL OR address=&#39;&#39;; -- （包括null和空字符串）需求： 查询有地址的学生(不包括null和空字符串)SELECT * FROM student WHERE address IS NOT NULL AND address&lt;&gt;&#39;&#39;; 模糊条件： like通常使用以下替换标记：% : 表示任意个字符_ : 表示一个字符 需求： 查询姓‘张’的学生SELECT * FROM student WHERE NAME LIKE &#39;李%&#39;;需求： 查询姓‘李’，且姓名只有两个字的学生SELECT * FROM student WHERE NAME LIKE &#39;李_&#39;; 聚合查询 聚合查询（使用聚合函数的查询）常用的聚合函数： sum() avg() max() min() count() 需求：查询学生的servlet的总成绩 (sum() :求和函数)SELECT SUM(servlet) AS &#39;servlet的总成绩&#39; FROM student;需求： 查询学生的servlet的平均分SELECT AVG(servlet) AS &#39;servlet的平均分&#39; FROM student;需求: 查询当前servlet最高分SELECT MAX(servlet) AS &#39;最高分&#39; FROM student;需求： 查询最低分SELECT MIN(servlet) AS &#39;最低分&#39; FROM student;需求： 统计当前有多少学生(count(字段))SELECT COUNT(*) FROM student;SELECT COUNT(id) FROM student;注意：count（）函数统计的数量不包含null的数据使用count统计表的记录数，要使用不包含null值的字段SELECT COUNT(age) FROM student; 分页查询 分页查询（limit 起始行,查询几行）起始行从0开始分页：当前页 每页显示多少条分页查询当前页的数据的sql:SELECT * FROM student LIMIT (当前页-1)*每页显示多少条,每页显示多少条; 需求： 查询第1,2条记录（第1页的数据）SELECT * FROM student LIMIT 0,2;查询第3,4条记录（第2页的数据）SELECT * FROM student LIMIT 2,2;查询第5,6条记录（第3页的数据）SELECT * FROM student LIMIT 4,2;查询第7,8条记录 (没有记录不显示)SELECT * FROM student LIMIT 6,2; 查询排序 查询排序（order by ）语法 ：order by 字段 asc/descasc: 顺序，正序。数值：递增，字母：自然顺序（a-z）desc: 倒序，反序。数值：递减，字母：自然反序(z-a)默认情况下，按照插入记录顺序排序SELECT * FROM student; 需求： 按照id顺序排序SELECT * FROM student ORDER BY id ASC;SELECT * FROM student ORDER BY id; -- 默认正序SELECT * FROM student ORDER BY id DESC;-- 反序注意：多个排序条件需求： 按照servlet正序，按照jsp的倒序SELECT * FROM student ORDER BY servlet ASC,jsp DESC; 分组查询 分组查询(group by) 需求： 查询男女的人数预期结果：男 3女 2 把学生按照性别分组(GROUP BY gender) 统计每组的人数(COUNT())`SELECT gender,COUNT() FROM student GROUP BY gender;` 分组查询后筛选 分组查询后筛选 需求： 查询总人数大于2的性别 查询男女的人数 筛选出人数大于2的记录(having)注意： 分组之前条件使用where关键字，分组之前条件使用having关键字SELECT gender,COUNT(*) FROM student WHERE GROUP BY gender HAVING COUNT(*)&gt;2;]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义标签]]></title>
    <url>%2F2016%2F01%2F14%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[自定义标签引入需求： 向浏览器输出当前客户的IP地址 （只能使用jsp标签） 第一个自定义标签开发步骤 编写一个普通的java类，继承SimpleTagSupport类，叫标签处理器类 1234567891011121314151617181920212223242526272829 /** * 标签处理器类 * @author APPle * 1）继承SimpleTagSupport * */public class ShowIpTag extends SimpleTagSupport&#123; private JspContext context; /** * 传入pageContext */ @Override public void setJspContext(JspContext pc) &#123; this.context = pc; &#125; /** * 2）覆盖doTag方法 */ @Override public void doTag() throws JspException, IOException &#123; //向浏览器输出客户的ip地址 PageContext pageContext = (PageContext)context; HttpServletRequest request = (HttpServletRequest)pageContext.getRequest(); String ip = request.getRemoteHost(); JspWriter out = pageContext.getOut(); out.write("使用自定义标签输出客户的IP地址："+ip); &#125;&#125; 在web项目的WEB-INF目录下建立itcast.tld文件，这个tld叫标签库的声明文件。（参考核心标签库的tld文件） 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;taglib xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd" version="2.1"&gt; &lt;!-- 标签库的版本 --&gt; &lt;tlib-version&gt;1.1&lt;/tlib-version&gt; &lt;!-- 标签库前缀 --&gt; &lt;short-name&gt;itcast&lt;/short-name&gt; &lt;!-- tld文件的唯一标记 --&gt; &lt;uri&gt;http://gz.itcast.cn&lt;/uri&gt; &lt;!-- 一个标签的声明 --&gt; &lt;tag&gt; &lt;!-- 标签名称 --&gt; &lt;name&gt;showIp&lt;/name&gt; &lt;!-- 标签处理器类的全名 --&gt; &lt;tag-class&gt;gz.itcast.a_tag.ShowIpTag&lt;/tag-class&gt; &lt;!-- 输出标签体内容格式 --&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;/tag&gt;&lt;/taglib&gt; 在jsp页面的头部导入自定义标签库&lt;%@taglib uri=&quot;http://gz.itcast.cn&quot; prefix=&quot;itcast&quot;%&gt; 在jsp中使用自定义标签&lt;itcast:showIp&gt;&lt;/itcast:showIp&gt; 自定义标签的执行过程问题： http://localhost:8080/day14/01.hellotag.jsp 如何访问到自定义标签？ 前提： tomcat服务器启动时，加载到每个web应用，加载每个web应用的WEB-INF目录下的所有文件！！！例如。web.xml, tld文件！！！ 访问01.hellotag.jsp资源 tomcat服务器把jsp文件翻译成java源文件-&gt;编译class-&gt;构造类对象-&gt;调用_jspService（）方法 检查jsp文件的taglib指令，是否存在一个名为http://gz.itcast.cn的tld文件。如果没有，则报错 上一步已经读到itcast.tld文件 读到到itcast.tld文件中查询是否存在为showIp的标签 找到对应的标签，则读到内容 得到 gz.itcast.a_tag.ShowIpTag 构造ShowIpTag对象，然后调用ShowIpTag里面的方法 自定义标签处理器类的生命周期SimpleTag接口： void setJspContext(JspContext pc)–设置pageContext对象，传入pageContext（一定调用）通过getJspCotext()方法得到pageContext对象 void setParent(JspTag parent)–设置父标签对象，传入父标签对象，如果没有父标签，则不调用此方法。通过getParent()方法得到父标签对象。 void setXXX(值) –设置属性值。 void setJspBody(JspFragment jspBody)–设置标签体内容。标签体内容封装到JspFragment对象中，然后传入JspFragment对象。通过getJspBody()方法得到标签体内容。如果没有标签体内容，则不会调用此方法 void doTag()–执行标签时调用的方法。（一定调用） 自定义标签的作用 控制标签体内容是否输出 控制标签余下内容是否输出 控制重复输出标签体内容 改变标签体内容 带属性的标签 属性的标签:在标签处理器中添加一个成语变量和setter方法//1.声明属性的成员变量 private Integer num;//2.关键点： 必须提供公开的setter方法，用于给属性赋值 123public void setNum(Integer num) &#123; this.num = num;&#125; 输出标签体内容格式JSP： 在传统标签中使用的。可以写和执行jsp的java代码。scriptless: 标签体不可以写jsp的java代码empty: 必须是空标签。tagdependent : 标签体内容可以写jsp的java代码，但不会执行。 编码实战JavaBeanJavaBean, 咖啡豆。 JavaBean是一种开发规范，可以说是一种技术。 JavaBean就是一个普通的java类。只有符合以下规定才能称之为javabean： 必须提供无参数的构造方法 类中属性都必须私有化(private) 该类提供公开的getter 和 setter方法 JavaBean的作用： 用于封装数据，保存数据。访问javabean只能使用getter和setter方法 JavaBean的使用场景： 项目中用到实体对象（entity）符合javabean规范 EL表达式访问对象属性。${student.name}调用getName()方法，符合javabean规范。 jsp标签中的属性赋值。 setNum（Integer num）。符合javabean规范。 jsp页面中使用javabean。符合javabean规范 问题：以下方法哪些属于javabean的规范的方法？ 答案 ：( 1，3，5，6 )注意： boolean类型的get方法名称叫 isXXX()方法 getName() getName(String name) setName(String name) setName() setFlag(boolean flag) isFlag() web开发模式MVC开发模式:Model - JavaBean实现。用于封装业务数据View - Jsp实现。用于显示数据Controller- servlet实现。用于控制model和view三层结构：dao层： 和数据访问相关的操作service层： 和业务逻辑相关的操作web层： 和用户直接交互相关的操作（传接参数，跳转页面） 总结自定义标签&amp;编码实战 自定义标签步骤：1.1. 编写标签处理器类，继承SimpleTagSupport类，覆盖doTag方法1.2. 在WEB-INF目录下建立tld文件，在tld配置标签1.3. 在jsp页面导入标签库，使用taglib指令1.4. 在jsp页面中使用标签库中的标签 自定义标签生命周期： SimpleTag接口： setJspContext(JspContext context) –传入pagContext对象 setParent(JspTag tag) –传入父标签对象setXXX(参数) –给属性赋值 setJspBody(JspFrament jspBody) –传入标签体内容 doTag() –执行标签 自定义标签的作用：3.1. 控制是否输出标签体内容 输出： this.getJspBody().invoke(null) 不输出: 不调用invoke(null)方法3.2. 控制标签余下内容是否输出 输出： 什么不都做！ 不输出： 抛出SkipPageException异常3.3. 重复输出标签体内容 重复调用： this.getJspBody().invoke(null)3.4. 修改标签体内容123456StringWriter sw = new StringWriter();this.getJspBody().invoke(sw);String content = sw.toString();//修改内容//手动输出到浏览器this.getJspContext().getOut().writer(修改过的内容); 3.5. 带属性的标签 a. 在标签处理器类中声明成员变量和setter方法，用于给属性变量赋值 b. 在tld文件中声明属性 c. 使用属性]]></content>
      <tags>
        <tag>Jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsp加强]]></title>
    <url>%2F2015%2F12%2F31%2FJsp%E5%8A%A0%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[Jsp的内置对象什么是内置对象？在jsp开发中，会频繁使用到一些对象。 例如HttpSession,ServletContext,ServletContext,HttpServletRequet。如果我们每次要使用这些对象都去创建这些对象就显示非常麻烦。所以Sun公司设计Jsp时，在jsp页面加载完毕之后就会自动帮开发者创建好这些对象，而开发者只需要直接使用这些对象调用方法即可！，这些创建好的对象就叫内置对象！！！！举例： servlet:HttpSession session = request.getSession(true); （需要开发者做）jsp:tomcat服务器：HttpSession session =request.getSession(true);(不需要开发者做)开发者做的： session.getId(); 九大内置对象 内置对象名 类型 request HttpServletRequest response HttpServletResponse config ServletConfig application ServletContext session HttpSession exception Throwable page Object(this) out JspWriter pageContext PageContext Out对象out对象类型，JspWriter类，相当于带缓存的PrintWriter PrintWriterwrier(内容)： 直接向浏览器写出内容。JspWriterwriter(内容): 向jsp缓冲区写出内容 当满足以下条件之一，缓冲区内容写出： 缓冲区满了 刷新缓存区 关闭缓存区 执行完毕jsp页面 pageContext对象pageContext对象的类型是PageContext，叫jsp的上下文对象 使用场景： 在自定义标签的时候，PageContext对象频繁使用到！！！ 可以获取其他八个内置对象 1234567891011121314151617181920public class 01_hello_jsp &#123; public void _jspService(request,response)&#123; 创建内置对象 HttpSession session =....; ServletConfig config = ....; 把8个经常使用的内置对象封装到PageContext对象中 PageContext pageContext = 封装； 调用method1方法 method1(pageContext); &#125; public void method1(PageContext pageContext)&#123; 希望使用内置对象 从PageContext对象中获取其他8个内置对象 JspWriter out =pageContext.getOut(); HttpServletRequest rquest = pageContext.getRequest(); ........ &#125;&#125; 本身是一个域对象 ServletContext context域 Servlet学习的 HttpServletRequest request域 Servlet学习的 HttpSession session域 Servlet学习的 PageContext page域 jsp学习的(包含四个) 问题：Servlet里面有几个域对象，Jsp里面有几个域对象？ 域对象作用： 保存数据和获取数据，用于共享数据 保存数据:1）默认情况下，保存到page域 pageContext.setAttribute(&quot;name&quot;);2）可以向四个域对象保存数据 pageContext.setAttribute(&quot;name&quot;,域范围常量) 获取数据:1）默认情况下，从page域获取 pageContext.getAttribute(&quot;name&quot;)2）可以从四个域中获取数据 pageContext.getAttribute(&quot;name&quot;,域范围常量) 域范围常量: PageContext.PAGE_SCOPE PageContext.REQUEST_SCOPE PageContext..SESSION_SCOPE PageContext.APPLICATION_SCOPE3）自动在四个域中搜索数据 pageContext.findAttribute(&quot;name&quot;);顺序： page域 -&gt; request域 -&gt; session域- &gt; context域（application域） Jsp中的四个域对象 域对象作用：保存数据 和 获取数据 ，用于数据共享。 域对象方法： setAttribute(“name”,Object) 保存数据 getAttribute(“name”) 获取数据 removeAttribute(“name”) 清除数据 域对象作用范围： page域： 只能在当前jsp页面中使用（当前页面） request域： 只能在同一个请求中使用（转发） session域： 只能在同一个会话（session对象）中使用（私有的） context域： 只能在同一个web应用中使用。（全局的） Jsp的最佳实践Servlet技术： 开发动态资源。是一个java类，最擅长写java代码jsp技术： 开发动态资源。通过java代码最擅长输出html代码。 各取所长： 在web项目中涉及到逻辑： 1）接收参数 servlet做 2）处理业务逻辑，返回结果 servlet做 3）显示数据到浏览器 jsp做 4）跳转到其他页面 servlet做servlet+jsp模式 servlet: 1）接收参数 2）处理业务逻辑 3）把结果保存到域对象中 4）跳转到jsp页面 Jsp: 1）从域对象取出数据 2）把数据显示到浏览器servlet的数据 -&gt; jsp页面List 使用域对象 共享数据 EL表达式 EL作用jsp的核心语法： jsp表达式 &lt;%=%&gt;和 jsp脚本&lt;% %&gt;。以后开发jsp的原则： 尽量在jsp页面中少写甚至不写java代码。使用EL表达式替换掉jsp表达式EL表达式作用： 向浏览器输出域对象中的变量值或表达式计算的结果！！！语法： ${变量或表达式} EL语法 输出基本数据类型变量 从四个域获取${name}指定域获取${pageScope.name}域范围： pageScoep / requestScope / sessionScope / applicationScope 输出对象的属性值Student 输出集合对象List 和 Map EL表达式计算 jsp标签 jsp标签的作用jsp标签作用：替换jsp脚本。 Jsp标签分类 内置标签（动作标签）： 不需要在jsp页面导入标签 jstl标签： 需要在jsp页面中导入标签 自定义标签 ： 开发者自行定义，需要在jsp页面导入标签 动作标签 转发标签： &lt;jsp:forward /&gt; 参数标签： &lt;jsp:pararm/&gt; 包含标签： &lt;jsp:include/&gt; 原理： 包含与被包含的页面先各自翻译成java源文件，然后再运行时合并在一起。（先翻译再合并），动态包含。静态包含 vs 动态包含的区别？1） 语法不同静态包含语法： &lt;%@inclue file=&quot;被包含的页面&quot;%&gt;动态包含语法： &lt;jsp:include page=&quot;被包含的页面&quot;&gt;2）参数传递不同静态包含不能向被包含页面传递参数动态包含可以向被包含页面传递参数3）原理不同静态包含： 先合并再翻译动态包含： 先翻译再合并 JSTL标签JSTL (全名：java standard tag libarary - java标准标签库 ) 核心标签库 （c标签库） 天天用国际化标签（fmt标签库）EL函数库（fn函数库）xml标签库（x标签库）sql标签库（sql标签库） 使用JSTL标签步骤 导入jstl支持的jar包（标签背后隐藏的java代码）注意：使用javaee5.0的项目自动导入jstl支持jar包 使用taglib指令导入标签库&lt;%@taglib uri=&quot;tld文件的uri名称&quot; prefix=&quot;简写&quot; %&gt; 在jsp中使用标签 核心标签库的重点标签：保存数据： &lt;c:set&gt;&lt;/c:set&gt;获取数据： &lt;c:out value=&quot;&quot;&gt;&lt;/c:out&gt;单条件判断 &lt;c:if test=&quot;&quot;&gt;&lt;/c:if&gt;多条件判断 &lt;c:choose&gt;&lt;/c:choose&gt; &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt; &lt;c:otherwise&gt;&lt;/c:otherwise&gt;循环数据 &lt;c:forEach&gt;&lt;/c:forEach&gt; &lt;c:forTokens items=&quot;&quot; delims=&quot;&quot;&gt;&lt;/c:forTokens&gt;重定向 &lt;c:redirect&gt;&lt;/c:redirect&gt;]]></content>
      <tags>
        <tag>Jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsp基础]]></title>
    <url>%2F2015%2F12%2F30%2FJsp%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Jsp基础 引入Servlet的作用： 用java语言开发动态资源的技术！！！Jsp的作用：用java语言（+html语言）开发动态资源的技术！！！Jsp就是servlet！！！ Jsp的特点 jsp的运行必须交给tomcat服务器！！！！ tomcat的work目录： tomcat服务器存放jsp运行时的临时文件 jsp页面既可以写html代码，也可以写java代码。 html页面不能写java代码。而jsp页面可以写java代码 Jsp的执行过程问题： 访问http://localhost:8080/day12/01.hello.jsp 如何显示效果？ 访问到01.hello.jsp页面，tomcat扫描到jsp文件，在%tomcat%/work把jsp文件翻译成java源文件 路径与自己配置的tomcat有关联，\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\work\Catalina\localhost\(01.hello.jsp -&gt; _01_hello_jsp.java) （翻译） tomcat服务器把java源文件编译成class字节码文件 （编译） （_01_hello_jsp.java -&gt; _01_hello_jsp.class） tomcat服务器构造_01_hello_jsp类对象 tomcat服务器调用_01_hello_jsp类里面方法，返回内容显示到浏览器。 第一次访问jsp： 走（1）（2）（3）（4）第n次访问jsp： 走（4）注意：jsp文件修改了或jsp的临时文件被删除了，要重新走翻译（1）和编译 （2）的过程 疑问问题： 为什么Jsp就是servlet！！！ 123456jsp翻译的java文件：public final class _01_hello_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent &#123;HttpJspBase类： public abstract class org.apache.jasper.runtime.HttpJspBase extends javax.servlet.http.HttpServlet implements javax.servlet.jsp.HttpJspPage &#123; 结论：Jsp就是一个servlet程序！！！ servlet的技术可以用在jsp程序中 jsp的技术并不是全部适用于servlet程序！ Servlet的生命周期： 构造方法（第1次访问）init方法（第1次访问）service方法destroy方法 Jsp的生命周期 翻译： jsp-&gt;java文件编译： java文件-&gt;class文件（servlet程序）构造方法（第1次访问）init方法（第1次访问）：_jspInit()service方法：_jspService()destroy方法：_jspDestroy() Jsp语法 Jsp表达式语法：&lt;%=变量或表达式%&gt;作用： 向浏览器输出变量的值或表达式计算的结果注意： 表达式的原理就是翻译成out.print(“变量” );通过该方法向浏览器写出内容表达式后面不需要带分号结束。 Jsp的脚本语法：&lt;%java代码 %&gt;作用： 执行java代码注意： 原理把脚本中java代码原封不动拷贝到_jspService方法中执行。 Jsp的声明语法：&lt;%! 变量或方法 %&gt;作用： 声明jsp的变量或方法注意: 变量翻译成成员变量，方法翻译成成员方法。&lt;% 变量 %&gt;为局部变量不能声明方法，&lt;%! 变量 %&gt;为全局变量 Jsp的注释语法： &lt;%!– jsp注释 –%&gt;注意： html的注释会被翻译和执行。而jsp的注释不能被翻译和执行。 Jsp的三大指令 include指令作用： 在当前页面用于包含其他页面语法： &lt;%@include file=”common/header.jsp”%&gt;注意： 原理是把被包含的页面（header.jsp）的内容翻译到包含页面(index.jsp)中,合并成翻译成一个java源文件，再编译运行！！，这种包含叫静态包含（源码包含）如果使用静态包含，被包含页面中不需要出现全局的html标签了！！！（如html、head、body） page指令作用： 告诉tomcat服务器如何翻译jsp文件 123456789101112&lt;%@ page language="java" --告诉服务器使用什么动态语言来翻译jsp文件 import="java.util.*" --告诉服务器java文件使用什么包,导入包，多个包之间用逗号分割 pageEncoding="utf-8" --告诉服务器使用什么编码翻译jsp文件（成java文件） contentType="text/html; charset=utf-8" --服务器发送浏览器的数据类型和内容编码 注意：在开发工具中，以后只需要设置pageEncoding即可解决中文乱码问题 errorPage="error.jsp" isErrorPage="false" buffer="8kb" session="true" isELIgnored="false"%&gt; 配置全局的错误处理页面： 123456789&lt;!-- 全局错误处理页面配置 --&gt;&lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/common/500.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/common/404.html&lt;/location&gt;&lt;/error-page&gt; taglib指令]]></content>
      <tags>
        <tag>Jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[会话管理]]></title>
    <url>%2F2015%2F12%2F29%2F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[会话管理： 管理浏览器客户端 和 服务器端之间会话过程中产生的会话数据。 Cookie技术Cookie特点：会话数据保存在浏览器客户端。 Cookie技术核心Cookie类：用于存储会话数据 构造Cookie对象Cookie(java.lang.String name, java.lang.String value) 设置cookievoid setPath(java.lang.String uri) 设置cookie的有效访问路径void setMaxAge(int expiry) ： 设置cookie的有效时间void setValue(java.lang.String newValue) ：设置cookie的值 发送cookie到浏览器端保存void response.addCookie(Cookie cookie) : 发送cookie 服务器接收cookieCookie[] request.getCookies() : 接收cookie Cookie原理 服务器创建cookie对象，把会话数据存储到cookie对象中。new Cookie(&quot;name&quot;,&quot;value&quot;); 服务器发送cookie信息到浏览器response.addCookie(cookie);举例： set-cookie: name=eric (隐藏发送了一个set-cookie名称的响应头) 浏览器得到服务器发送的cookie，然后保存在浏览器端。 浏览器在下次访问服务器时，会带着cookie信息举例： cookie: name=eric (隐藏带着一个叫cookie名称的请求头) 服务器接收到浏览器带来的cookie信息request.getCookies(); Cookie的细节 void setPath(java.lang.String uri) ：设置cookie的有效访问路径。有效路径指的是cookie的有效路径保存在哪里，那么浏览器在有效路径下访问服务器时就会带着cookie信息，否则不带cookie信息。 void setMaxAge(int expiry) ： 设置cookie的有效时间。 正整数：表示cookie数据保存浏览器的缓存目录（硬盘中），数值表示保存的时间。负整数：表示cookie数据保存浏览器的内存中。浏览器关闭cookie就丢失了！！零：表示删除同名的cookie数据 Cookie数据类型只能保存非中文字符串类型的。可以保存多个cookie，但是浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。 Session技术引入Cookie的局限： Cookie只能存字符串类型。不能保存对象只能存非中文。1个Cookie的容量不超过4KB。 如果要保存非字符串，超过4kb内容，只能使用session技术！！！ Session特点：会话数据保存在服务器端。（内存中） Session技术核心HttpSession类：用于保存会话数据 创建或得到session对象HttpSession getSession()HttpSession getSession(boolean create) 设置session对象void setMaxInactiveInterval(int interval) ： 设置session的有效时间void invalidate() ： 销毁session对象java.lang.String getId() ： 得到session编号 保存会话数据到session对象void setAttribute(java.lang.String name, java.lang.Object value) ： 保存数据java.lang.Object getAttribute(java.lang.String name) ： 获取数据void removeAttribute(java.lang.String name) ： 清除数据 Session原理问题： 服务器能够识别不同的浏览者！！前提： 在哪个session域对象保存数据，就必须从哪个域对象取出！！！！ 浏览器1：(给s1分配一个唯一的标记：s001,把s001发送给浏览器) 创建session对象，保存会话数据HttpSession session = request.getSession(); --保存会话数据s1 浏览器1 的新窗口（带着s001的标记到服务器查询，s001-&gt;s1,返回s1） 得到session对象的会话数据HttpSession session = request.getSession(); --可以取出 s1 新的浏览器1：(没有带s001,不能返回s1) 得到session对象的会话数据HttpSession session = request.getSession(); --不可以取出 s2 浏览器2：(没有带s001,不能返回s1) 得到session对象的会话数据HttpSession session = request.getSession(); --不可以取出 s3 代码解读：HttpSession session = request.getSession(); 第一次访问创建session对象，给session对象分配一个唯一的ID，叫JSESSIONIDnew HttpSession(); 把JSESSIONID作为Cookie的值发送给浏览器保存Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, sessionID);response.addCookie(cookie); 第二次访问的时候，浏览器带着JSESSIONID的cookie访问服务器 服务器得到JSESSIONID，在服务器的内存中搜索是否存放对应编号的session对象。 if(找到){ return map.get(sessionID); } Map&lt;String,HttpSession&gt; &lt;&quot;s001&quot;, s1&gt; &lt;&quot;s001,&quot;s2&gt; 如果找到对应编号的session对象，直接返回该对象 如果找不到对应编号的session对象，创建新的session对象，继续走1的流程 结论：通过JSESSION的cookie值在服务器找session对象！！！！！ Sesson细节 java.lang.String getId() ： 得到session编号 两个getSession方法： getSession(true) / getSession() : 创建或得到session对象。没有匹配的session编号，自动创建新的session对象。 getSession(false): 得到session对象。没有匹配的session编号，返回null void setMaxInactiveInterval(int interval) ： 设置session的有效时间session对象销毁时间： 默认情况30分服务器自动回收 修改session回收时间 全局修改session有效时间 &lt;!-- 修改session全局有效时间:分钟 --&gt; &lt;session-config&gt; &lt;session-timeout&gt;1&lt;/session-timeout&gt; &lt;/session-config&gt; 手动销毁session对象void invalidate()： 销毁session对象 如何避免浏览器的JSESSIONID的cookie随着浏览器关闭而丢失的问题123456/*** 手动发送一个硬盘保存的cookie给浏览器*/Cookie c = new Cookie("JSESSIONID",session.getId());c.setMaxAge(60*60);response.addCookie(c); 总结 Cookie技术： 会话数据保存在浏览器客户端。 Cookie核心的API：在服务器端创建Cookie对象Cookeie cookie = new Cookie(&quot;name&quot;,&quot;value&quot;);把cookie发送给浏览器端（通过响应头：set-cookie）response.addCookie(cookie);浏览器带着cookie信息访问服务器（通过请求头：cookie），服务器得到cookie信息Cookie[] cookies = request.getCookies(); 局限：只能保存字符串类型，不能保存中文一个cookie不能超过4kb Session技术：会话数据保存在服务器端。（内存） Session核心的API：创建或得到session对象HttpSession session = request.getSession(); //创建或得到session对象request.getSession(false); //得到session对象会话数据保存session对象中，和得到会话数据session.setAttribute(&quot;name&quot;,Object); 保存数据session.getAttribute(&quot;name&quot;) 得到数据注意：session.setIntactiveInterval(时间); 设置session过期时间session.invalidate() 手动销毁session对象 此文章知识点来源传智博客发布的学习教程里面。以后会定期的更新，记录自己的学习历程，总结所学的知识点。]]></content>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet编程]]></title>
    <url>%2F2015%2F12%2F28%2Fservlet%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[如何开发一个Servlet步骤 编写java类，继承HttpServlet类 重新doGet和doPost方法 在wed.xml文件中进行配置 Servlet程序交给tomcat服务器运行12345678910111213141516&lt;!-- 配置一个servlet --&gt; &lt;!-- servlet的配置 --&gt; &lt;servlet&gt; &lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;!-- servlet的类全名： 包名+简单类名 --&gt; &lt;servlet-class&gt;gz.itcast.a_servlet.FirstServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- servlet的映射配置 --&gt; &lt;servlet-mapping&gt; &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;!-- servlet的映射路径（访问servlet的名称） --&gt; &lt;url-pattern&gt;/first&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 前提：tomcat服务器启动时，首先加载webapps中的每个web应用的web.xml配置文件http:// :http协议localhost：在本地host文件中查找对应的IP地址（127.0.0.1）8080：找到tomcat服务器(对应的端口)/day10：在tomcat的webapps目录下找day10的目录/first：资源名称 在day10的web.xml中查找是否有匹配的url-pattern的内容（/first） 如果匹配，则取出对应的servlet-name的名称，查看是否有对应的servlet配置 如果匹配，则取出对应的servlet配置信息中的class内容： 通过反射:构造FirstServlet的对象，然后调用FirstServlet里面的方法 Servlet的映射文件精确匹配： url-pattern配置 路径 /first http：//localhost:8080/day10/first /itcast/demo1 http：//localhost:8080/day10/itcast/demo1 模糊匹配： url-pattern配置 路径 /* http：//localhost:8080/day10/任意路径 /itcast/* http：//localhost:8080/day10/itcast/任意路径 *.后缀名（.do/.action） http：//localhost:8080/day10/任意路径.do 注意 url-pattern要么以 / 开头，要么以*开头。 例如， itcast是非法路径。 不能同时使用两种模糊匹配，例如 /itcast/*.do是非法路径 当有输入的URL有多个servlet同时被匹配的情况下： 精确匹配优先。（长的最像优先被匹配） 以后缀名结尾的模糊url-pattern优先级最低！！！ Servlet缺省路径 servlet的缺省路径(&lt;url-pattern&gt;/&lt;/url-pattern&gt;）是在tomcat服务器内置的一个路径。该路径对应的是一个DefaultServlet（缺省Servlet）。这个缺省的Servlet的作用是用于解析web应用的静态资源文件。问题： URL输入http://localhost:8080/day10/index.html 如何读取文件？？？？ 到当前day10应用下的web.xml文件查找是否有匹配的url-pattern。 如果没有匹配的url-pattern，则交给tomcat的内置的DefaultServlet处理 DefaultServlet程序到day10应用的根目录下查找是存在一个名称为index.html的静态文件。 如果找到该文件，则读取该文件内容，返回给浏览器。 如果找不到该文件，则返回404错误页面。结论： 先找动态资源，再找静态资源。 Servlet的生命周期引入Servlet的生命周期： servlet类对象什么时候创建，什么时候调用什么方法，什么时候销毁。以前的对象： new Student（）； stu.study(); stu=null;Servlet程序的生命周期由tomcat服务器控制的！！！！ Servlet重要的四个生命周期方法构造方法： 创建servlet对象的时候调用。默认情况下，第一次访问servlet的时候创建servlet对象。只调用1次。证明servlet对象在tomcat是单实例的。init方法： 创建完servlet对象的时候调用。只调用1次。service方法： 每次发出请求时调用。调用n次。destroy方法： 销毁servlet对象的时候调用。停止服务器或者重新部署web应用时销毁servlet对象。只调用1次。 伪代码演示Servlet的生命周期Tomcat内部代码运行: 通过映射找到到servlet-class的内容，字符串： gz.itcast.a_servlet.FirstServlet 通过反射构造FirstServlet对象 得到字节码对象Class clazz = class.forName(&quot;gz.itcast.a_servlet.FirstServlet&quot;); 调用无参数的构造方法来构造对象Object obj = clazz.newInstance(); —1.servlet的构造方法被调用 创建ServletConfig对象，通过反射调用init方法 得到方法对象Method m = clazz.getDeclareMethod(&quot;init&quot;,ServletConfig.class); 调用方法m.invoke(obj,config);–2.servlet的init方法被调用 创建request，response对象，通过反射调用service方法 得到方法对象Methodm m =clazz.getDeclareMethod(&quot;service&quot;,HttpServletRequest.class,HttpServletResponse.class); 调用方法m.invoke(obj,request,response); –3.servlet的service方法被调用 当tomcat服务器停止或web应用重新部署，通过反射调用destroy方法 得到方法对象Method m = clazz.getDeclareMethod(&quot;destroy&quot;,null); 调用方法m.invoke(obj,null); –4.servlet的destroy方法被调用 用时序图来演示servlet的生命周期 Servlet的自动加载默认情况下，第一次访问servlet的时候创建servlet对象。如果servlet的构造方法或init方法中执行了比较多的逻辑代码，那么导致用户第一次访问sevrlet的时候比较慢。改变servlet创建对象的时机： 提前到加载web应用的时候！！！在servlet的配置信息中，加上一个即可！！12345&lt;servlet&gt; &lt;servlet-name&gt;LifeDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;gz.itcast.c_life.LifeDemo&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; Servlet的多线程并发问题注意： servlet对象在tomcat服务器是单实例多线程的。 因为servlet是多线程的，所以当多个servlet的线程同时访问了servlet的共享数据，如成员变量，可能会引发线程安全问题。解决办法： 把使用到共享数据的代码块进行同步（使用synchronized关键字进行同步） 建议在servlet类中尽量不要使用成员变量。如果确实要使用成员，必须同步。而且尽量缩小同步代码块的范围。（哪里使用到了成员变量，就同步哪里！！），以避免因为同步而导致并发效率降低。Servlet学习 HttpServletRequest 请求对象：获取请求信息HttpServletResponse 响应对象： 设置响应对象ServletConfig对象 servlet配置对象ServletContext对象 servlet的上下文对象 ServletConfig对象作用 ServletConfig对象:＜主要是用于加载servlet的初始化参数。在一个web应用可以存在多个ServletConfig对象（一个Servlet对应一个ServletConfig对象） 对象创建和得到创建时机： 在创建完servlet对象之后，在调用init方法之前创建。得到对象： 直接从有参数的init方法中得到！！！ servlet的初始化参数配置123456789&lt;servlet&gt; &lt;servlet-name&gt;ConfigDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;gz.itcast.f_config.ConfigDemo&lt;/servlet-class&gt; &lt;!-- 初始参数： 这些参数会在加载web应用的时候，封装到ServletConfig对象中 --&gt; &lt;init-param&gt; &lt;param-name&gt;path&lt;/param-name&gt; &lt;param-value&gt;e:/b.txt&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; 注意： servlet的参数只能由当前的这个sevlet获取！！！！ServletConfig的API： java.lang.String getInitParameter(java.lang.String name) 根据参数名获取参数值 java.util.Enumeration getInitParameterNames() 获取所有参数 ServletContext getServletContext() 得到servlet上下文对象 java.lang.String getServletName() 得到servlet的名称 ServletContext对象引入 ServletContext对象,叫做Servlet的上下文对象。表示一个当前的web应用环境。一个web应用中只有一个ServletContext对象。 对象创建和得到创建时机：加载web应用时创建ServletContext对象。得到对象：从ServletConfig对象的getServletContext方法得到Sun公司设计:1234567891011121314创建ServletContext对象 ServletContext context = new ServletContext()创建ServletConfig对象 ServetConfig config = new ServletConfig(); config.setServletContxt(context);class ServletConfig&#123; ServletContext context; public ServletContext getServletContxt()&#123; return contxt; &#125;&#125; public void init( ServletConfig config )&#123; 得到ServletConfig对象 从ServletConfig对象中得到ServletContext对象 SerlvetContext context = config.getServletContext();&#125; ServletContext对象的核心API(作用) java.lang.String getContextPath() –得到当前web应用的路径(用在请求重定向的资源名称中) java.lang.String getInitParameter(java.lang.String name) –得到web应用的初始化参数java.util.Enumeration getInitParameterNames() void setAttribute(java.lang.String name, java.lang.Object object) –域对象有关的方法java.lang.Object getAttribute(java.lang.String name)void removeAttribute(java.lang.String name) RequestDispatcher getRequestDispatcher(java.lang.String path) –转发（类似于重定向） java.lang.String getRealPath(java.lang.String path) –得到web应用的资源文件java.io.InputStream getResourceAsStream(java.lang.String path) 域对象有关的方法域对象：作用是用于保存数据，获取数据。可以在不同的动态资源之间共享数据。案例：12345678910111213141516案例1：response.sendRedirect("/Servlet2?name=eric")String request.getParameter("name");案例2://保存数据//1.得到域对象ServletContext context = this.getServletContext();//2.把数据保存到域对象中context.setAttribute("name", "eric");//获取数据//1.得到域对象ServletContext context = this.getServletContext();//2.从域对象中取出数据String name = (String)context.getAttribute("name"); 方案1： 可以通过传递参数的形式，共享数据。局限：只能传递字符串类型。方案2： 可以使用域对象共享数据，好处：可以共享任何类型的数据！！！！！ ServletContext就是一个域对象！！！！ 保存数据：void setAttribute(java.lang.String name, java.lang.Object object) 获取数据： java.lang.Object getAttribute(java.lang.String name) 删除数据： void removeAttribute(java.lang.String name) ServletContext域对象：作用范围在整个web应用中有效！！！所有域对象 HttpServletRequet 域对象ServletContext域对象HttpSession 域对象PageContext域对象 转发法RequestDispatcher getRequestDispatcher(java.lang.String path)转发request.setAttribute(&quot;name&quot;,&quot;rose&quot;);this.getServletContext().getRequestDispatcher(&quot;/GetDateServlet&quot;).forward(request, response); 地址栏不会改变 转发只能转发到当前web应用内的资源 可以在转发过程中，可以把数据保存到request域对象中 重定向response.sendRedirect(&quot;/day10/GetDataServlet&quot;); 地址栏会改变，变成重定向到地址。 重定向可以跳转到当前web应用，或其他web应用，甚至是外部域名网站。 不能再重定向的过程，把数据保存到request中。 结论： 如果要使用request域对象进行数据共享，只能用转发技术！！！ 总结Servlet编程 Servlet生命周期（重点） 构造方法： 创建servlet对象。默认情况下，第一次访问servlet对象时。只调用1次。 init方法（有参）： 创建完servlet对象后调用。只调用1次。注意： 会调用无参的init方法。 service方法： servlet提供服务的方法。每次发出请求调用。注意： request对象 ，response对象 destroy方法：tomcat服务器停止或web应用重新部署，servlet对象销毁，destroy方法被调用。 ServletConfig对象 获取servlet的初始化参数： getInitParameter(“name”);getInitParameterNames(); ServletContext对象 得到web应用路径： context.getContextPath();request.getContextPath(); 等价于上面的代码 得到web应用参数： context.getInitParameter(“name”);context.getInitParameterNames(); 域对象: context.setAttribute(“name”,Object): 保存数据context.getAttribute(“name”) 得到数据context.removeAttribue(“name”) 清除数据 转发 context.getRequestDispatcher(“路径”).forward(request,response);request.getRequestDispacher(“路径”).forward(request,response); 等价于上面的代码 得到web应用中的资源文件 context.getRealPath(“路径”)context.getResourceAsStream(“路径”); 此文章知识点来源传智博客发布的学习教程里面。以后会定期的更新，记录自己的学习历程，总结所学的知识点。]]></content>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http协议]]></title>
    <url>%2F2015%2F12%2F24%2FHttp%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[什么是http协议http协议：对浏览器客户端和服务端之间数据传输的格式规范数据传输的格式规范 查看http协议的工具 使用火狐的firebug插件（右键-&gt;firebug-&gt;网络） 使用谷歌的“审查元素” 使用系统自带的telnet工具（远程访问工具） telnet localhost 8080 访问tomcat服务器 ctrl 回车 可以看到回显 输入请求内容 回车，即可查看到服务器响应信息。 http协议版本 http1.0：当前浏览器客户端与服务器端建立连接之后，只能发送一次请求，一次请求之后连接关闭。 http1.1：当前浏览器客户端与服务器端建立连接之后，可以在一次连接中发送多次请求。（基本都使用1.1） http请求 GET /day09/hello HTTP/1.1 -请求行Host: localhost:8080 –请求头（多个key-value对象）User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateConnection: keep-alive –一个空行name=eric&amp;password=123456 –（可选）实体内容 请求资源与方式URL:统一资源定位符，只能定位互联网资源，是URI的子集。URI:统一资源标记符，用于标记任何资源，可以是本地文件系统，局域网资源，互联网资源。常见的请求方式：GET、POST、HEAD、TRACE、PUT、CONNECT、DELETE GET方式提交 地址栏（URI）会跟上参数数据。以？开头，多个参数之间以&amp;分割。 GET提交参数数据有限制，不超过1KB。 GET方式不适合提交敏感密码。 注意： 浏览器直接访问的请求，默认提交方式是GET方式 POST方式提交 参数不会跟着URI后面。参数而是跟在请求的实体内容中。没有？开头，多个参数之间以&amp;分割。 POST提交的参数数据没有限制。 POST方式提交敏感数据。 请求头 Accept: text/html,image/* – 浏览器接受的数据类型Accept-Charset: ISO-8859-1 – 浏览器接受的编码格式Accept-Encoding: gzip,compress –浏览器接受的数据压缩格式Accept-Language: en-us,zh- –浏览器接受的语言Host: www.it315.org:80 –（必须的）当前请求访问的目标地址（主机:端口）If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT –浏览器最后的缓存时间Referer: http://lglife.github.io/ – 当前请求来自于哪里User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0) –浏览器类型Cookie:name=eric – 浏览器保存的cookie信息Connection: close/Keep-Alive – 浏览器跟服务器连接状态。close: 连接关闭 keep-alive：保存连接。Date: Tue, 11 Jul 2000 18:23:51 GMT – 请求发出的时间 HttpServletRequest对象HttpServletRequest对象作用是用于获取请求数据。 核心的API： 请求行： request.getMethod(); 请求方式 request.getRequetURI()/ request.getRequetURL()请求资源 request.getProtocol() 请求http协议版本 请求头： request.getHeader("名称") 根据请求头获取请求值 request.getHeaderNames() 获取所有的请求头名称 实体内容: request.getInputStream() 获取实体内容数据 获取参数: request.getParameter("参数名"); 根据参数名获取参数值（注意，只能获取一个值的参数） request.getParameterValue("参数名“)；根据参数名获取参数值（可以获取多个值的参数） request.getParameterNames(); 获取所有参数名称列表 获取GET方式参数： request.getQueryString(); 获取POST方式参数： request.getInputStream(); 修改POST方式参数编码： request.setCharacterEncoding("utf-8"); 修改GET方式参数编码： 手动解码：String name = new String(name.getBytes("iso-8859-1"),"utf-8"); http请求 HTTP/1.1 200 OK –响应行Server: Apache-Coyote/1.1 –响应头（key-vaule）Content-Length: 24Date: Fri, 30 Jan 2015 01:54:57 GMT –一个空行this is hello servlet!!! –实体内容 状态码服务器处理请求的结果（状态）,常见的状态 200：表示请求处理完成并完美返回 302：表示请求需要进一步细化。 404：表示客户访问的资源找不到。 500：表示服务器的资源发送错误。（服务器内部错误） 常见的响应头 Location: http://lglife.github.io/ -表示重定向的地址，该头和302的状态码一起使用。Server:apache tomcat —表示服务器的类型Content-Encoding: gzip – 表示服务器发送给浏览器的数据压缩类型Content-Length: 80 –表示服务器发送给浏览器的数据长度Content-Language: zh-cn –表示服务器支持的语言Content-Type: text/html; charset=GB2312 –表示服务器发送给浏览器的数据类型及内容编码Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT –表示服务器资源的最后修改时间Refresh: 1;url=http://lglife.github.io/ –表示定时刷新Content-Disposition: attachment; filename=aaa.zip –表示告诉浏览器以下载方式打开资源（下载文件时用到）Transfer-Encoding: chunkedSet-Cookie:SS=Q0=5Lb_nQ; path=/search –表示服务器发送给浏览器的cookie信息（会话管理用到）Expires: -1 –表示通知浏览器不进行缓存Cache-Control: no-cachePragma: no-cacheConnection: close/Keep-Alive –表示服务器和浏览器的连接状态。close：关闭连接 keep-alive:保存连接 HttpServletResponse对象HttpServletResponse对象修改响应信息： 响应行： response.setStatus() 设置状态码 响应头： response.setHeader("name","value") 设置响应头 实体内容： response.getWriter().writer(); 发送字符实体内容 response.getOutputStream().writer() 发送字节实体内容 此文章知识点来源传智博客发布的学习教程里面。以后会定期的更新，记录自己的学习历程，总结所学的知识点。]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime text2 插件安装及激活]]></title>
    <url>%2F2015%2F12%2F23%2Fublime-text2-%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%8A%E6%BF%80%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[sublime text2 破解打开Sublime Text，看到标题栏上面带有（unregistered）,表示没有注册。复制下面代码，打开注册页面（help-enter license）,点击 use license即可12345678910111213141516171819202122232425----- BEGIN LICENSE -----Andrew WeberSingle User LicenseEA7E-855605813A03DD 5E4AD9E6 6C0EEB94 BC99798F942194A6 02396E98 E62C9979 4BB979FE91424C9D A45400BF F6747D88 2FB8807890F5CC94 1CDC92DC 8457107A F151657B1D22E383 A997F016 42397640 33F41CFCE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D5CDB7036 E56DE1C0 EFCC0840 650CD3A6B98FC99C 8FAC73EE D2B95564 DF450523------ END LICENSE ------ sublime text2 插件安装打开命令输入框（view-show console）或者按ctrl+`调出窗口，复制下面代码按回车：1import urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()) 点击Preferences下拉窗口有 package control 即安装组件成功。按ctrl+shift+p或者点击package control调出命令面板，输入install package 回车或者点击，然后就可以选择自己想要的插件安装。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2015%2F12%2F17%2FHello%20World%2F</url>
    <content type="text"><![CDATA[终于有时间来写写了，离搭建好博客的时间一个有半个月了，期间发生了各种奇葩的事情（一个高中玩的好的朋友居然失踪了，各种联系，各种奔波，居然TMD自己玩失踪）。 开始还想写记录下来搭建博客的一下步骤的，现在过的太久，遇到的问题差不多忘记了（记忆力不好），这也是我搭建博客的主要原因之一，记录自己学习的知识点，以及工作中遇到的一些问题。 我主要就是参考下面的资料搭建了 独立博客搭建教程 hexo特性配置 hexo 静态博客使用指南]]></content>
      <tags>
        <tag>随性</tag>
      </tags>
  </entry>
</search>